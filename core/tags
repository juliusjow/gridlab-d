!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A	complex.h	/^typedef enum {I='i',J='j',A='d', R='r'} CNOTATION; \/**< complex number notation to use *\/$/;"	e	enum:__anon12
ACCEPT	find.c	778;"	d	file:
ACCEPT	load.c	1096;"	d	file:
ADDALL	find.c	292;"	d	file:
ADDOBJ	find.c	290;"	d	file:
AEQ	cmex.h	56;"	d
AFTER	find.h	/^typedef enum {EQ=0,LT=1,GT=2,NE=3,LE=4,GE=5,NOT=6,BETWEEN=7,BEFORE=8,AFTER=9,SAME=10,DIFF=11,MATCH=12,LIKE=13,UNLIKE=14,FINDOP_END} FINDOP;$/;"	e	enum:__anon14
AF_ABS	aggregate.h	17;"	d
AGGREGATION	aggregate.h	/^} AGGREGATION; \/**< the aggregation type *\/$/;"	t	typeref:struct:s_aggregate
AGGREGATOR	aggregate.h	/^typedef enum {AGGR_NOP, AGGR_MIN, AGGR_MAX, AGGR_AVG, AGGR_STD, AGGR_MBE, AGGR_MEAN, AGGR_VAR, AGGR_SKEW, AGGR_KUR, AGGR_GAMMA, AGGR_COUNT, AGGR_SUM, AGGR_PROD} AGGREGATOR; \/**< the aggregation method to use *\/$/;"	t	typeref:enum:__anon1
AGGRPART	aggregate.h	/^typedef enum {AP_NONE, AP_REAL, AP_IMAG, AP_MAG, AP_ANG, AP_ARG} AGGRPART; \/**< the part of complex values to aggregate *\/$/;"	t	typeref:enum:__anon2
AGGR_AVG	aggregate.h	/^typedef enum {AGGR_NOP, AGGR_MIN, AGGR_MAX, AGGR_AVG, AGGR_STD, AGGR_MBE, AGGR_MEAN, AGGR_VAR, AGGR_SKEW, AGGR_KUR, AGGR_GAMMA, AGGR_COUNT, AGGR_SUM, AGGR_PROD} AGGREGATOR; \/**< the aggregation method to use *\/$/;"	e	enum:__anon1
AGGR_COUNT	aggregate.h	/^typedef enum {AGGR_NOP, AGGR_MIN, AGGR_MAX, AGGR_AVG, AGGR_STD, AGGR_MBE, AGGR_MEAN, AGGR_VAR, AGGR_SKEW, AGGR_KUR, AGGR_GAMMA, AGGR_COUNT, AGGR_SUM, AGGR_PROD} AGGREGATOR; \/**< the aggregation method to use *\/$/;"	e	enum:__anon1
AGGR_GAMMA	aggregate.h	/^typedef enum {AGGR_NOP, AGGR_MIN, AGGR_MAX, AGGR_AVG, AGGR_STD, AGGR_MBE, AGGR_MEAN, AGGR_VAR, AGGR_SKEW, AGGR_KUR, AGGR_GAMMA, AGGR_COUNT, AGGR_SUM, AGGR_PROD} AGGREGATOR; \/**< the aggregation method to use *\/$/;"	e	enum:__anon1
AGGR_KUR	aggregate.h	/^typedef enum {AGGR_NOP, AGGR_MIN, AGGR_MAX, AGGR_AVG, AGGR_STD, AGGR_MBE, AGGR_MEAN, AGGR_VAR, AGGR_SKEW, AGGR_KUR, AGGR_GAMMA, AGGR_COUNT, AGGR_SUM, AGGR_PROD} AGGREGATOR; \/**< the aggregation method to use *\/$/;"	e	enum:__anon1
AGGR_MAX	aggregate.h	/^typedef enum {AGGR_NOP, AGGR_MIN, AGGR_MAX, AGGR_AVG, AGGR_STD, AGGR_MBE, AGGR_MEAN, AGGR_VAR, AGGR_SKEW, AGGR_KUR, AGGR_GAMMA, AGGR_COUNT, AGGR_SUM, AGGR_PROD} AGGREGATOR; \/**< the aggregation method to use *\/$/;"	e	enum:__anon1
AGGR_MBE	aggregate.h	/^typedef enum {AGGR_NOP, AGGR_MIN, AGGR_MAX, AGGR_AVG, AGGR_STD, AGGR_MBE, AGGR_MEAN, AGGR_VAR, AGGR_SKEW, AGGR_KUR, AGGR_GAMMA, AGGR_COUNT, AGGR_SUM, AGGR_PROD} AGGREGATOR; \/**< the aggregation method to use *\/$/;"	e	enum:__anon1
AGGR_MEAN	aggregate.h	/^typedef enum {AGGR_NOP, AGGR_MIN, AGGR_MAX, AGGR_AVG, AGGR_STD, AGGR_MBE, AGGR_MEAN, AGGR_VAR, AGGR_SKEW, AGGR_KUR, AGGR_GAMMA, AGGR_COUNT, AGGR_SUM, AGGR_PROD} AGGREGATOR; \/**< the aggregation method to use *\/$/;"	e	enum:__anon1
AGGR_MIN	aggregate.h	/^typedef enum {AGGR_NOP, AGGR_MIN, AGGR_MAX, AGGR_AVG, AGGR_STD, AGGR_MBE, AGGR_MEAN, AGGR_VAR, AGGR_SKEW, AGGR_KUR, AGGR_GAMMA, AGGR_COUNT, AGGR_SUM, AGGR_PROD} AGGREGATOR; \/**< the aggregation method to use *\/$/;"	e	enum:__anon1
AGGR_NOP	aggregate.h	/^typedef enum {AGGR_NOP, AGGR_MIN, AGGR_MAX, AGGR_AVG, AGGR_STD, AGGR_MBE, AGGR_MEAN, AGGR_VAR, AGGR_SKEW, AGGR_KUR, AGGR_GAMMA, AGGR_COUNT, AGGR_SUM, AGGR_PROD} AGGREGATOR; \/**< the aggregation method to use *\/$/;"	e	enum:__anon1
AGGR_PROD	aggregate.h	/^typedef enum {AGGR_NOP, AGGR_MIN, AGGR_MAX, AGGR_AVG, AGGR_STD, AGGR_MBE, AGGR_MEAN, AGGR_VAR, AGGR_SKEW, AGGR_KUR, AGGR_GAMMA, AGGR_COUNT, AGGR_SUM, AGGR_PROD} AGGREGATOR; \/**< the aggregation method to use *\/$/;"	e	enum:__anon1
AGGR_SKEW	aggregate.h	/^typedef enum {AGGR_NOP, AGGR_MIN, AGGR_MAX, AGGR_AVG, AGGR_STD, AGGR_MBE, AGGR_MEAN, AGGR_VAR, AGGR_SKEW, AGGR_KUR, AGGR_GAMMA, AGGR_COUNT, AGGR_SUM, AGGR_PROD} AGGREGATOR; \/**< the aggregation method to use *\/$/;"	e	enum:__anon1
AGGR_STD	aggregate.h	/^typedef enum {AGGR_NOP, AGGR_MIN, AGGR_MAX, AGGR_AVG, AGGR_STD, AGGR_MBE, AGGR_MEAN, AGGR_VAR, AGGR_SKEW, AGGR_KUR, AGGR_GAMMA, AGGR_COUNT, AGGR_SUM, AGGR_PROD} AGGREGATOR; \/**< the aggregation method to use *\/$/;"	e	enum:__anon1
AGGR_SUM	aggregate.h	/^typedef enum {AGGR_NOP, AGGR_MIN, AGGR_MAX, AGGR_AVG, AGGR_STD, AGGR_MBE, AGGR_MEAN, AGGR_VAR, AGGR_SKEW, AGGR_KUR, AGGR_GAMMA, AGGR_COUNT, AGGR_SUM, AGGR_PROD} AGGREGATOR; \/**< the aggregation method to use *\/$/;"	e	enum:__anon1
AGGR_VAR	aggregate.h	/^typedef enum {AGGR_NOP, AGGR_MIN, AGGR_MAX, AGGR_AVG, AGGR_STD, AGGR_MBE, AGGR_MEAN, AGGR_VAR, AGGR_SKEW, AGGR_KUR, AGGR_GAMMA, AGGR_COUNT, AGGR_SUM, AGGR_PROD} AGGREGATOR; \/**< the aggregation method to use *\/$/;"	e	enum:__anon1
AGT	cmex.h	59;"	d
ALT	cmex.h	58;"	d
AND	find.h	/^typedef enum {OR=-2,AND=-1,FT_END=0, FT_ID=1, FT_SIZE=2, FT_CLASS=3, FT_PARENT=4, FT_RANK=5, FT_CLOCK=6, FT_PROPERTY=7, FT_NAME=8,$/;"	e	enum:__anon15
ANE	cmex.h	57;"	d
AP_ANG	aggregate.h	/^typedef enum {AP_NONE, AP_REAL, AP_IMAG, AP_MAG, AP_ANG, AP_ARG} AGGRPART; \/**< the part of complex values to aggregate *\/$/;"	e	enum:__anon2
AP_ARG	aggregate.h	/^typedef enum {AP_NONE, AP_REAL, AP_IMAG, AP_MAG, AP_ANG, AP_ARG} AGGRPART; \/**< the part of complex values to aggregate *\/$/;"	e	enum:__anon2
AP_IMAG	aggregate.h	/^typedef enum {AP_NONE, AP_REAL, AP_IMAG, AP_MAG, AP_ANG, AP_ARG} AGGRPART; \/**< the part of complex values to aggregate *\/$/;"	e	enum:__anon2
AP_MAG	aggregate.h	/^typedef enum {AP_NONE, AP_REAL, AP_IMAG, AP_MAG, AP_ANG, AP_ARG} AGGRPART; \/**< the part of complex values to aggregate *\/$/;"	e	enum:__anon2
AP_NONE	aggregate.h	/^typedef enum {AP_NONE, AP_REAL, AP_IMAG, AP_MAG, AP_ANG, AP_ARG} AGGRPART; \/**< the part of complex values to aggregate *\/$/;"	e	enum:__anon2
AP_REAL	aggregate.h	/^typedef enum {AP_NONE, AP_REAL, AP_IMAG, AP_MAG, AP_ANG, AP_ARG} AGGRPART; \/**< the part of complex values to aggregate *\/$/;"	e	enum:__anon2
Arg	complex.h	/^	inline double Arg(double a)  \/**< set angle *\/$/;"	f	class:complex
Arg	complex.h	/^	inline double Arg(void) const \/**< compute angle *\/$/;"	f	class:complex
B	stream.c	67;"	d	file:
BEFORE	find.h	/^typedef enum {EQ=0,LT=1,GT=2,NE=3,LE=4,GE=5,NOT=6,BETWEEN=7,BEFORE=8,AFTER=9,SAME=10,DIFF=11,MATCH=12,LIKE=13,UNLIKE=14,FINDOP_END} FINDOP;$/;"	e	enum:__anon14
BEGIN_REPEAT	load.c	1106;"	d	file:
BETWEEN	find.h	/^typedef enum {EQ=0,LT=1,GT=2,NE=3,LE=4,GE=5,NOT=6,BETWEEN=7,BEFORE=8,AFTER=9,SAME=10,DIFF=11,MATCH=12,LIKE=13,UNLIKE=14,FINDOP_END} FINDOP;$/;"	e	enum:__anon14
BINARY	stream.c	20;"	d	file:
BINDIR	cmex.h	21;"	d
BP_CLASS	debug.c	/^typedef enum {BP_MODULE, BP_CLASS, BP_OBJECT, BP_PASS, BP_RANK, BP_TIME, BP_CLOCK, BP_ERROR} BREAKPOINTTYPE; \/**< breakpoint types that are supported *\/$/;"	e	enum:__anon51	file:
BP_CLOCK	debug.c	/^typedef enum {BP_MODULE, BP_CLASS, BP_OBJECT, BP_PASS, BP_RANK, BP_TIME, BP_CLOCK, BP_ERROR} BREAKPOINTTYPE; \/**< breakpoint types that are supported *\/$/;"	e	enum:__anon51	file:
BP_ERROR	debug.c	/^typedef enum {BP_MODULE, BP_CLASS, BP_OBJECT, BP_PASS, BP_RANK, BP_TIME, BP_CLOCK, BP_ERROR} BREAKPOINTTYPE; \/**< breakpoint types that are supported *\/$/;"	e	enum:__anon51	file:
BP_MODULE	debug.c	/^typedef enum {BP_MODULE, BP_CLASS, BP_OBJECT, BP_PASS, BP_RANK, BP_TIME, BP_CLOCK, BP_ERROR} BREAKPOINTTYPE; \/**< breakpoint types that are supported *\/$/;"	e	enum:__anon51	file:
BP_OBJECT	debug.c	/^typedef enum {BP_MODULE, BP_CLASS, BP_OBJECT, BP_PASS, BP_RANK, BP_TIME, BP_CLOCK, BP_ERROR} BREAKPOINTTYPE; \/**< breakpoint types that are supported *\/$/;"	e	enum:__anon51	file:
BP_PASS	debug.c	/^typedef enum {BP_MODULE, BP_CLASS, BP_OBJECT, BP_PASS, BP_RANK, BP_TIME, BP_CLOCK, BP_ERROR} BREAKPOINTTYPE; \/**< breakpoint types that are supported *\/$/;"	e	enum:__anon51	file:
BP_RANK	debug.c	/^typedef enum {BP_MODULE, BP_CLASS, BP_OBJECT, BP_PASS, BP_RANK, BP_TIME, BP_CLOCK, BP_ERROR} BREAKPOINTTYPE; \/**< breakpoint types that are supported *\/$/;"	e	enum:__anon51	file:
BP_TIME	debug.c	/^typedef enum {BP_MODULE, BP_CLASS, BP_OBJECT, BP_PASS, BP_RANK, BP_TIME, BP_CLOCK, BP_ERROR} BREAKPOINTTYPE; \/**< breakpoint types that are supported *\/$/;"	e	enum:__anon51	file:
BRANCH	version.h	15;"	d
BREAKPOINT	debug.c	/^} BREAKPOINT; \/**< the structure for a breakpoint entry *\/$/;"	t	typeref:struct:s_breakpoint	file:
BREAKPOINTTYPE	debug.c	/^typedef enum {BP_MODULE, BP_CLASS, BP_OBJECT, BP_PASS, BP_RANK, BP_TIME, BP_CLOCK, BP_ERROR} BREAKPOINTTYPE; \/**< breakpoint types that are supported *\/$/;"	t	typeref:enum:__anon51	file:
BTUPHPW	cmex.h	49;"	d
BUFFERSIZE	load.c	234;"	d	file:
BUILD	build.h	1;"	d
BUILD	legal.c	42;"	d	file:
BUILD	version.h	11;"	d
CALLBACKS	object.h	/^} CALLBACKS; \/**< core callback function table *\/$/;"	t	typeref:struct:s_callbacks
CASE	gui.c	84;"	d	file:
CATCH	exception.h	23;"	d
CDECL	gridlabd.h	67;"	d
CDECL	gridlabd.h	70;"	d
CFPGAL	cmex.h	47;"	d
CF_CLASS	find.h	42;"	d
CF_CLOCK	find.h	44;"	d
CF_CONSTANT	find.h	55;"	d
CF_FLAGS	find.h	52;"	d
CF_GROUPID	find.h	54;"	d
CF_ID	find.h	41;"	d
CF_INSVC	find.h	50;"	d
CF_LAT	find.h	48;"	d
CF_LONG	find.h	49;"	d
CF_MODULE	find.h	53;"	d
CF_NAME	find.h	47;"	d
CF_OUTSVC	find.h	51;"	d
CF_PARENT	find.h	45;"	d
CF_PROPERTY	find.h	46;"	d
CF_RANK	find.h	43;"	d
CF_SIZE	find.h	40;"	d
CHECK	output.c	45;"	d	file:
CLASS	class.h	/^typedef struct s_class_list CLASS;$/;"	t	typeref:struct:s_class_list
CLASSMAGIC	class.h	/^typedef enum {CLASSVALID=0xc44d822e} CLASSMAGIC; \/* this is used to uniquely identify classes *\/$/;"	t	typeref:enum:__anon6
CLASSNAME	class.h	/^typedef char CLASSNAME[64]; \/**< the name a GridLAB class *\/$/;"	t
CLASSVALID	class.h	/^typedef enum {CLASSVALID=0xc44d822e} CLASSMAGIC; \/* this is used to uniquely identify classes *\/$/;"	e	enum:__anon6
CLOCK_PROP	load_xml_handle.h	/^	CLOCK_PROP$/;"	e	enum:__anon30
CLOCK_STATE	load_xml_handle.h	/^	CLOCK_STATE,$/;"	e	enum:__anon30
CMDMAP	cmex.c	/^} CMDMAP;$/;"	t	typeref:struct:__anon49	file:
CNOTATION	complex.h	/^typedef enum {I='i',J='j',A='d', R='r'} CNOTATION; \/**< complex number notation to use *\/$/;"	t	typeref:enum:__anon12
CNOTATION_DEFAULT	complex.h	22;"	d
COMMENT	load.c	153;"	d	file:
COMMENT	load.c	156;"	d	file:
COMPAREFUNC	find.h	/^typedef int (*COMPAREFUNC)(void*, FINDVALUE);$/;"	t
COMPRESS	stream.c	37;"	d	file:
COPY	find.c	785;"	d	file:
COPY	load.c	1104;"	d	file:
COPYRIGHT	version.h	9;"	d
COUNT	find.c	288;"	d	file:
CWATER	cmex.h	48;"	d
DATEFORMAT	globals.h	/^typedef enum {DF_ISO=0, DF_US=1, DF_EURO=2} DATEFORMAT;$/;"	t	typeref:enum:__anon18
DATETIME	timestamp.h	/^} DATETIME; \/**< the s_datetime structure *\/$/;"	t	typeref:struct:s_datetime
DAY	timestamp.c	45;"	d	file:
DBG_NEXT	debug.c	/^typedef enum {DBG_QUIT,DBG_RUN,DBG_NEXT} DEBUGCMD; \/**< commands that are automatically repeated when a \\p NULL command is entered *\/$/;"	e	enum:__anon50	file:
DBG_QUIT	debug.c	/^typedef enum {DBG_QUIT,DBG_RUN,DBG_NEXT} DEBUGCMD; \/**< commands that are automatically repeated when a \\p NULL command is entered *\/$/;"	e	enum:__anon50	file:
DBG_RUN	debug.c	/^typedef enum {DBG_QUIT,DBG_RUN,DBG_NEXT} DEBUGCMD; \/**< commands that are automatically repeated when a \\p NULL command is entered *\/$/;"	e	enum:__anon50	file:
DEBUGCMD	debug.c	/^typedef enum {DBG_QUIT,DBG_RUN,DBG_NEXT} DEBUGCMD; \/**< commands that are automatically repeated when a \\p NULL command is entered *\/$/;"	t	typeref:enum:__anon50	file:
DECOMPRESS	stream.c	58;"	d	file:
DEFAULT_FORMAT	save.c	16;"	d	file:
DELALL	find.c	293;"	d	file:
DELEGATEDTYPE	class.h	/^} DELEGATEDTYPE; \/**< type delegation specification *\/$/;"	t	typeref:struct:s_delegatedtype
DELEGATEDVALUE	class.h	/^} DELEGATEDVALUE; \/**< a delegation entry *\/$/;"	t	typeref:struct:s_delegatedvalue
DELOBJ	find.c	291;"	d	file:
DF_EURO	globals.h	/^typedef enum {DF_ISO=0, DF_US=1, DF_EURO=2} DATEFORMAT;$/;"	e	enum:__anon18
DF_ISO	globals.h	/^typedef enum {DF_ISO=0, DF_US=1, DF_EURO=2} DATEFORMAT;$/;"	e	enum:__anon18
DF_US	globals.h	/^typedef enum {DF_ISO=0, DF_US=1, DF_EURO=2} DATEFORMAT;$/;"	e	enum:__anon18
DIFF	find.h	/^typedef enum {EQ=0,LT=1,GT=2,NE=3,LE=4,GE=5,NOT=6,BETWEEN=7,BEFORE=8,AFTER=9,SAME=10,DIFF=11,MATCH=12,LIKE=13,UNLIKE=14,FINDOP_END} FINDOP;$/;"	e	enum:__anon14
DLEXT	config.h	5;"	d
DLEXT	load.c	134;"	d	file:
DLEXT	module.c	27;"	d	file:
DLEXT	module.c	37;"	d	file:
DLLOAD	module.c	29;"	d	file:
DLLOAD	module.c	40;"	d	file:
DLLOAD	module.c	42;"	d	file:
DLSYM	module.c	30;"	d	file:
DLSYM	module.c	44;"	d	file:
DONE	find.c	786;"	d	file:
DONE	load.c	1105;"	d	file:
DOW0	timestamp.c	60;"	d	file:
E	complex.h	24;"	d
EMPTY	load_xml_handle.h	/^	EMPTY = 0,$/;"	e	enum:__anon30
ENDCATCH	exception.h	24;"	d
END_REPEAT	load.c	1108;"	d	file:
ENTERING	load.c	3306;"	d	file:
EQ	find.h	/^typedef enum {EQ=0,LT=1,GT=2,NE=3,LE=4,GE=5,NOT=6,BETWEEN=7,BEFORE=8,AFTER=9,SAME=10,DIFF=11,MATCH=12,LIKE=13,UNLIKE=14,FINDOP_END} FINDOP;$/;"	e	enum:__anon14
ERROR	cmex.c	92;"	d	file:
ETPDIR	cmex.h	22;"	d
EUC_HEATLOAD	enduse.h	11;"	d
EUC_IS220	enduse.h	10;"	d
EVENT	cmex.h	/^} EVENT;$/;"	t	typeref:struct:__anon8
EVENT	realtime.c	/^} EVENT;$/;"	t	typeref:struct:s_eventlist	file:
EXCEPTIONHANDLER	exception.h	/^} EXCEPTIONHANDLER; \/**< the exception handler structure *\/$/;"	t	typeref:struct:s_exception_handler
EXEFORMAT	cmex.h	23;"	d
EXITING	load.c	3307;"	d	file:
EXPORT	gridlabd.h	75;"	d
EXPORT	gridlabd.h	78;"	d
EXTERN	gridlabd.h	87;"	d
EXTERN	gridlabd.h	91;"	d
EXTERN	gridlabd.h	93;"	d
EXTERN	gridlabd.h	99;"	d
EXTRA_CXXFLAGS	load.c	690;"	d	file:
FAILED	globals.h	/^typedef enum {FAILED=FALSE, SUCCESS=TRUE} STATUS;$/;"	e	enum:__anon17
FALSE	globals.h	26;"	d
FF_EXIST	find.h	93;"	d
FF_READ	find.h	95;"	d
FF_RW	find.h	96;"	d
FF_WRITE	find.h	94;"	d
FILESTREAM	output.h	/^typedef enum {FS_IN = 0, FS_STD = 1, FS_ERR = 2} FILESTREAM;$/;"	t	typeref:enum:__anon45
FINDLIST	find.h	/^} FINDLIST;$/;"	t	typeref:struct:s_findlist
FINDOP	find.h	/^typedef enum {EQ=0,LT=1,GT=2,NE=3,LE=4,GE=5,NOT=6,BETWEEN=7,BEFORE=8,AFTER=9,SAME=10,DIFF=11,MATCH=12,LIKE=13,UNLIKE=14,FINDOP_END} FINDOP;$/;"	t	typeref:enum:__anon14
FINDOP_END	find.h	/^typedef enum {EQ=0,LT=1,GT=2,NE=3,LE=4,GE=5,NOT=6,BETWEEN=7,BEFORE=8,AFTER=9,SAME=10,DIFF=11,MATCH=12,LIKE=13,UNLIKE=14,FINDOP_END} FINDOP;$/;"	e	enum:__anon14
FINDPGM	find.h	/^} FINDPGM;$/;"	t	typeref:struct:s_findpgm
FINDTYPE	find.h	/^	FT_LAT=9, FT_LONG=10, FT_INSVC=11, FT_OUTSVC=12, FT_FLAGS=13, FT_MODULE=14, FT_GROUPID=15} FINDTYPE;$/;"	t	typeref:enum:__anon15
FINDVALUE	find.h	/^} FINDVALUE; \/**< a search value *\/$/;"	t	typeref:union:__anon16
FL_GROUP	find.h	90;"	d
FL_NEW	find.h	89;"	d
FMT_INT64	platform.h	20;"	d
FMT_INT64	platform.h	43;"	d
FN_CREATE	load.c	223;"	d	file:
FN_INIT	load.c	224;"	d	file:
FN_ISA	load.c	231;"	d	file:
FN_NOTIFY	load.c	225;"	d	file:
FN_PLC	load.c	230;"	d	file:
FN_POSTSYNC	load.c	229;"	d	file:
FN_PRESYNC	load.c	227;"	d	file:
FN_RECALC	load.c	226;"	d	file:
FN_SYNC	load.c	228;"	d	file:
FOUND	find.c	289;"	d	file:
FOUNDACTION	find.h	/^typedef void (*FOUNDACTION)(FINDLIST *, struct s_object_list *);$/;"	t
FSTAT	load.c	164;"	d	file:
FSTAT	load.c	170;"	d	file:
FS_ERR	output.h	/^typedef enum {FS_IN = 0, FS_STD = 1, FS_ERR = 2} FILESTREAM;$/;"	e	enum:__anon45
FS_IN	output.h	/^typedef enum {FS_IN = 0, FS_STD = 1, FS_ERR = 2} FILESTREAM;$/;"	e	enum:__anon45
FS_STD	output.h	/^typedef enum {FS_IN = 0, FS_STD = 1, FS_ERR = 2} FILESTREAM;$/;"	e	enum:__anon45
FT_CLASS	find.h	/^typedef enum {OR=-2,AND=-1,FT_END=0, FT_ID=1, FT_SIZE=2, FT_CLASS=3, FT_PARENT=4, FT_RANK=5, FT_CLOCK=6, FT_PROPERTY=7, FT_NAME=8,$/;"	e	enum:__anon15
FT_CLOCK	find.h	/^typedef enum {OR=-2,AND=-1,FT_END=0, FT_ID=1, FT_SIZE=2, FT_CLASS=3, FT_PARENT=4, FT_RANK=5, FT_CLOCK=6, FT_PROPERTY=7, FT_NAME=8,$/;"	e	enum:__anon15
FT_END	find.h	/^typedef enum {OR=-2,AND=-1,FT_END=0, FT_ID=1, FT_SIZE=2, FT_CLASS=3, FT_PARENT=4, FT_RANK=5, FT_CLOCK=6, FT_PROPERTY=7, FT_NAME=8,$/;"	e	enum:__anon15
FT_FLAGS	find.h	/^	FT_LAT=9, FT_LONG=10, FT_INSVC=11, FT_OUTSVC=12, FT_FLAGS=13, FT_MODULE=14, FT_GROUPID=15} FINDTYPE;$/;"	e	enum:__anon15
FT_GROUPID	find.h	/^	FT_LAT=9, FT_LONG=10, FT_INSVC=11, FT_OUTSVC=12, FT_FLAGS=13, FT_MODULE=14, FT_GROUPID=15} FINDTYPE;$/;"	e	enum:__anon15
FT_ID	find.h	/^typedef enum {OR=-2,AND=-1,FT_END=0, FT_ID=1, FT_SIZE=2, FT_CLASS=3, FT_PARENT=4, FT_RANK=5, FT_CLOCK=6, FT_PROPERTY=7, FT_NAME=8,$/;"	e	enum:__anon15
FT_INSVC	find.h	/^	FT_LAT=9, FT_LONG=10, FT_INSVC=11, FT_OUTSVC=12, FT_FLAGS=13, FT_MODULE=14, FT_GROUPID=15} FINDTYPE;$/;"	e	enum:__anon15
FT_LAT	find.h	/^	FT_LAT=9, FT_LONG=10, FT_INSVC=11, FT_OUTSVC=12, FT_FLAGS=13, FT_MODULE=14, FT_GROUPID=15} FINDTYPE;$/;"	e	enum:__anon15
FT_LONG	find.h	/^	FT_LAT=9, FT_LONG=10, FT_INSVC=11, FT_OUTSVC=12, FT_FLAGS=13, FT_MODULE=14, FT_GROUPID=15} FINDTYPE;$/;"	e	enum:__anon15
FT_MODULE	find.h	/^	FT_LAT=9, FT_LONG=10, FT_INSVC=11, FT_OUTSVC=12, FT_FLAGS=13, FT_MODULE=14, FT_GROUPID=15} FINDTYPE;$/;"	e	enum:__anon15
FT_NAME	find.h	/^typedef enum {OR=-2,AND=-1,FT_END=0, FT_ID=1, FT_SIZE=2, FT_CLASS=3, FT_PARENT=4, FT_RANK=5, FT_CLOCK=6, FT_PROPERTY=7, FT_NAME=8,$/;"	e	enum:__anon15
FT_OUTSVC	find.h	/^	FT_LAT=9, FT_LONG=10, FT_INSVC=11, FT_OUTSVC=12, FT_FLAGS=13, FT_MODULE=14, FT_GROUPID=15} FINDTYPE;$/;"	e	enum:__anon15
FT_PARENT	find.h	/^typedef enum {OR=-2,AND=-1,FT_END=0, FT_ID=1, FT_SIZE=2, FT_CLASS=3, FT_PARENT=4, FT_RANK=5, FT_CLOCK=6, FT_PROPERTY=7, FT_NAME=8,$/;"	e	enum:__anon15
FT_PROPERTY	find.h	/^typedef enum {OR=-2,AND=-1,FT_END=0, FT_ID=1, FT_SIZE=2, FT_CLASS=3, FT_PARENT=4, FT_RANK=5, FT_CLOCK=6, FT_PROPERTY=7, FT_NAME=8,$/;"	e	enum:__anon15
FT_RANK	find.h	/^typedef enum {OR=-2,AND=-1,FT_END=0, FT_ID=1, FT_SIZE=2, FT_CLASS=3, FT_PARENT=4, FT_RANK=5, FT_CLOCK=6, FT_PROPERTY=7, FT_NAME=8,$/;"	e	enum:__anon15
FT_SIZE	find.h	/^typedef enum {OR=-2,AND=-1,FT_END=0, FT_ID=1, FT_SIZE=2, FT_CLASS=3, FT_PARENT=4, FT_RANK=5, FT_CLOCK=6, FT_PROPERTY=7, FT_NAME=8,$/;"	e	enum:__anon15
FULLNAME	object.h	/^typedef char FULLNAME[1024]; \/** Full object name (including space name) *\/$/;"	t
FUNCTION	class.h	/^} FUNCTION;$/;"	t	typeref:struct:s_function_map
FUNCTIONADDR	class.h	/^typedef int64 (*FUNCTIONADDR)(void*,...); \/** the entry point of a module function *\/$/;"	t
FUNCTIONNAME	class.h	/^typedef char FUNCTIONNAME[64]; \/**< the name of a function (not used) *\/$/;"	t
F_OK	platform.h	35;"	d
GE	find.h	/^typedef enum {EQ=0,LT=1,GT=2,NE=3,LE=4,GE=5,NOT=6,BETWEEN=7,BEFORE=8,AFTER=9,SAME=10,DIFF=11,MATCH=12,LIKE=13,UNLIKE=14,FINDOP_END} FINDOP;$/;"	e	enum:__anon14
GETADDR	object.h	321;"	d
GETBT	stream.c	65;"	d	file:
GETC	stream.c	60;"	d	file:
GETD	stream.c	59;"	d	file:
GETL	stream.c	62;"	d	file:
GETQ	stream.c	63;"	d	file:
GETS	stream.c	61;"	d	file:
GET_BLOCK	schedule.h	40;"	d
GET_CALENDAR	schedule.h	44;"	d
GET_MINUTE	schedule.h	45;"	d
GET_VALUE	schedule.h	41;"	d
GLD_INTERPOLATE	interpolate.h	3;"	d
GLD_MATCH	match.h	6;"	d
GLOBAL	globals.h	14;"	d
GLOBAL	globals.h	163;"	d
GLOBAL	globals.h	17;"	d
GLOBALVAR	globals.h	/^} GLOBALVAR;$/;"	t	typeref:struct:s_globalvar
GLOBAL_PROP	load_xml_handle.h	/^	GLOBAL_PROP,	\/\/	setting a global variable$/;"	e	enum:__anon30
GLOBAL_STATE	load_xml_handle.h	/^	GLOBAL_STATE,	\/\/	setting up for global variables$/;"	e	enum:__anon30
GL_CATCH	gridlabd.h	235;"	d
GL_ENDCATCH	gridlabd.h	238;"	d
GL_THROW	gridlabd.h	/^inline void GL_THROW(char *format, ...)$/;"	f
GL_THROW	gridlabd.h	226;"	d
GL_TRY	gridlabd.h	205;"	d
GMTIME	timestamp.c	69;"	d	file:
GT	find.h	/^typedef enum {EQ=0,LT=1,GT=2,NE=3,LE=4,GE=5,NOT=6,BETWEEN=7,BEFORE=8,AFTER=9,SAME=10,DIFF=11,MATCH=12,LIKE=13,UNLIKE=14,FINDOP_END} FINDOP;$/;"	e	enum:__anon14
GUIENTITY	gui.h	/^} GUIENTITY;$/;"	t	typeref:struct:s_guientity
GUIENTITYTYPE	gui.h	/^} GUIENTITYTYPE;$/;"	t	typeref:enum:__anon19
GUISTREAMFN	gui.h	/^typedef  int (*GUISTREAMFN)(void*,char*,...);$/;"	t
GUI_ACTION	gui.h	/^	GUI_ACTION, \/\/ an action button$/;"	e	enum:__anon19
GUI_BROWSE	gui.h	/^	GUI_BROWSE, \/\/ a text browsing entity$/;"	e	enum:__anon19
GUI_CHECK	gui.h	/^	GUI_CHECK, \/\/ a check box (set)$/;"	e	enum:__anon19
GUI_GRAPH	gui.h	/^	GUI_GRAPH, \/\/ a graphing presentation$/;"	e	enum:__anon19
GUI_GROUP	gui.h	/^	GUI_GROUP, \/\/ a group of entities with a labeled border around it$/;"	e	enum:__anon19
GUI_INPUT	gui.h	/^	GUI_INPUT, \/\/ an input textbox$/;"	e	enum:__anon19
GUI_PAGE	gui.h	/^	GUI_PAGE, \/\/ a page group (includes navigation |< < > >| buttons at top)$/;"	e	enum:__anon19
GUI_RADIO	gui.h	/^	GUI_RADIO, \/\/ a radio button (enumeration)$/;"	e	enum:__anon19
GUI_ROW	gui.h	/^	GUI_ROW, \/\/ a row group$/;"	e	enum:__anon19
GUI_SELECT	gui.h	/^	GUI_SELECT, \/\/ a select drop down (enumeration)$/;"	e	enum:__anon19
GUI_SPAN	gui.h	/^	GUI_SPAN, \/\/ a group of entities that are not in columns$/;"	e	enum:__anon19
GUI_STATUS	gui.h	/^	GUI_STATUS, \/\/ the status message of the page$/;"	e	enum:__anon19
GUI_TAB	gui.h	/^	GUI_TAB, \/\/ a tab group (includes tabs at top)$/;"	e	enum:__anon19
GUI_TABLE	gui.h	/^	GUI_TABLE, \/\/ a tabulate presentation$/;"	e	enum:__anon19
GUI_TEXT	gui.h	/^	GUI_TEXT, \/\/ a plain text entity $/;"	e	enum:__anon19
GUI_TITLE	gui.h	/^	GUI_TITLE, \/\/ the title of the page, tab, or block$/;"	e	enum:__anon19
GUI_UNKNOWN	gui.h	/^	GUI_UNKNOWN=0,$/;"	e	enum:__anon19
GetLastError	server.c	/^int GetLastError()$/;"	f
HAVE_ALARM	config.h	8;"	d
HAVE_ATEXIT	config.h	11;"	d
HAVE_DLFCN_H	config.h	14;"	d
HAVE_GETCWD	config.h	20;"	d
HAVE_GET_NPROCS	config.h	23;"	d
HAVE_INTTYPES_H	config.h	26;"	d
HAVE_LIBCPPUNIT	gridlabd.h	62;"	d
HAVE_MALLOC	config.h	33;"	d
HAVE_MALLOC_H	config.h	36;"	d
HAVE_MEMORY_H	config.h	39;"	d
HAVE_MEMSET	config.h	42;"	d
HAVE_PTHREAD	config.h	48;"	d
HAVE_PUTENV	config.h	51;"	d
HAVE_REALLOC	config.h	55;"	d
HAVE_STDBOOL_H	config.h	61;"	d
HAVE_STDINT_H	config.h	64;"	d
HAVE_STDLIB_H	config.h	67;"	d
HAVE_STRCHR	config.h	70;"	d
HAVE_STRERROR	config.h	73;"	d
HAVE_STRFTIME	config.h	76;"	d
HAVE_STRINGS_H	config.h	79;"	d
HAVE_STRING_H	config.h	82;"	d
HAVE_STRRCHR	config.h	85;"	d
HAVE_SYS_STAT_H	config.h	88;"	d
HAVE_SYS_TIME_H	config.h	91;"	d
HAVE_SYS_TYPES_H	config.h	94;"	d
HAVE_TZSET	config.h	97;"	d
HAVE_UNISTD_H	config.h	100;"	d
HAVE_VPRINTF	config.h	103;"	d
HAVE__BOOL	config.h	106;"	d
HAVE___SYNC_ADD_AND_FETCH	config.h	109;"	d
HAVE___SYNC_BOOL_COMPARE_AND_SWAP	config.h	112;"	d
HERE	find.c	779;"	d	file:
HERE	load.c	1097;"	d	file:
HOMEVAR	globals.c	103;"	d	file:
HOMEVAR	globals.c	109;"	d	file:
HOUR	timestamp.c	46;"	d	file:
HTTP	server.c	/^} HTTP;$/;"	t	typeref:struct:s_http	file:
HTTP_ACCEPTED	server.c	219;"	d	file:
HTTP_BADGATEWAY	server.c	253;"	d	file:
HTTP_BADREQUEST	server.c	233;"	d	file:
HTTP_CONFLICT	server.c	242;"	d	file:
HTTP_CONTINUE	server.c	214;"	d	file:
HTTP_CREATED	server.c	218;"	d	file:
HTTP_EXPECTATIONFAILED	server.c	250;"	d	file:
HTTP_FORBIDDEN	server.c	236;"	d	file:
HTTP_FOUND	server.c	227;"	d	file:
HTTP_GATEWAYTIMEOUT	server.c	255;"	d	file:
HTTP_GONE	server.c	243;"	d	file:
HTTP_INTERNALSERVERERROR	server.c	251;"	d	file:
HTTP_LENGTHREQUIRED	server.c	244;"	d	file:
HTTP_METHODNOTALLOWED	server.c	238;"	d	file:
HTTP_MOVEDPERMANENTLY	server.c	226;"	d	file:
HTTP_MULTIPLECHOICES	server.c	225;"	d	file:
HTTP_NOCONTENT	server.c	221;"	d	file:
HTTP_NONAUTHORITATIVEINFORMATION	server.c	220;"	d	file:
HTTP_NOTACCEPTABLE	server.c	239;"	d	file:
HTTP_NOTFOUND	server.c	237;"	d	file:
HTTP_NOTIMPLEMENTED	server.c	252;"	d	file:
HTTP_NOTMODIFIED	server.c	229;"	d	file:
HTTP_OK	server.c	217;"	d	file:
HTTP_PARTIALCONTENT	server.c	223;"	d	file:
HTTP_PAYMENTREQUIRED	server.c	235;"	d	file:
HTTP_PRECONDITIONFAILED	server.c	245;"	d	file:
HTTP_PROXYAUTHENTICATIONREQUIRED	server.c	240;"	d	file:
HTTP_REQUESTEDRANGENOTSATISFIABLE	server.c	249;"	d	file:
HTTP_REQUESTENTITYTOOLARGE	server.c	246;"	d	file:
HTTP_REQUESTTIMEOUT	server.c	241;"	d	file:
HTTP_REQUESTURITOOLARGE	server.c	247;"	d	file:
HTTP_RESETCONTENT	server.c	222;"	d	file:
HTTP_SEEOTHER	server.c	228;"	d	file:
HTTP_SERVICEUNAVAILABLE	server.c	254;"	d	file:
HTTP_SWITCHPROTOCOL	server.c	215;"	d	file:
HTTP_TEMPORARYREDIRECT	server.c	231;"	d	file:
HTTP_UNAUTHORIZED	server.c	234;"	d	file:
HTTP_UNSUPPORTEDMEDIATYPE	server.c	248;"	d	file:
HTTP_USEPROXY	server.c	230;"	d	file:
HTTP_VERSIONNOTSUPPORTED	server.c	256;"	d	file:
I	complex.h	/^typedef enum {I='i',J='j',A='d', R='r'} CNOTATION; \/**< complex number notation to use *\/$/;"	e	enum:__anon12
INCLUDELIST	load.c	/^} INCLUDELIST;$/;"	t	typeref:struct:s_include_list	file:
INDEX	index.h	/^} INDEX;	\/**< the index structure *\/$/;"	t	typeref:struct:s_index
INFINITY	platform.h	25;"	d
INIT	globals.h	15;"	d
INIT	globals.h	164;"	d
INIT	globals.h	18;"	d
INIT	gridlabd.h	88;"	d
INIT	gridlabd.h	95;"	d
INIT	gridlabd.h	98;"	d
INTEGER	cmex.h	/^typedef enum {INTEGER, REAL} PROPERTYTYPE;$/;"	e	enum:__anon9
INVALID_SOCKET	server.c	21;"	d	file:
INVALID_THREADPOOL	threadpool.h	15;"	d
ISLEAPYEAR	timestamp.h	43;"	d
Im	complex.h	/^	inline double & Im(void) \/**< access to imaginary part *\/$/;"	f	class:complex
IsFinite	complex.h	/^	inline bool IsFinite(void) { return isfinite(r) && isfinite(i); };$/;"	f	class:complex
IsZero	complex.h	/^	inline bool IsZero(double err=0.0) \/**< zero test *\/$/;"	f	class:complex
J	complex.h	/^typedef enum {I='i',J='j',A='d', R='r'} CNOTATION; \/**< complex number notation to use *\/$/;"	e	enum:__anon12
KEYWORD	class.h	/^} KEYWORD;$/;"	t	typeref:struct:s_keyword
KML_H	kml.h	9;"	d
LE	find.h	/^typedef enum {EQ=0,LT=1,GT=2,NE=3,LE=4,GE=5,NOT=6,BETWEEN=7,BEFORE=8,AFTER=9,SAME=10,DIFF=11,MATCH=12,LIKE=13,UNLIKE=14,FINDOP_END} FINDOP;$/;"	e	enum:__anon14
LIBINIT	module.h	/^typedef CLASS *(*LIBINIT)(const CALLBACKS*,void*,int,char*[]);$/;"	t
LIKE	find.h	/^typedef enum {EQ=0,LT=1,GT=2,NE=3,LE=4,GE=5,NOT=6,BETWEEN=7,BEFORE=8,AFTER=9,SAME=10,DIFF=11,MATCH=12,LIKE=13,UNLIKE=14,FINDOP_END} FINDOP;$/;"	e	enum:__anon14
LIST	list.h	/^} LIST;$/;"	t	typeref:struct:s_list
LISTITEM	list.h	/^} LISTITEM;$/;"	t	typeref:struct:s_listitem
LITERAL	find.c	783;"	d	file:
LITERAL	load.c	1102;"	d	file:
LOAD	load_xml_handle.h	/^	LOAD,			\/\/	got load tag & not in a module$/;"	e	enum:__anon30
LOADER	module.c	/^typedef MODULE *(*LOADER)(const char *, int, char *[]);$/;"	t	file:
LOCALE	local.h	/^} LOCALE;$/;"	t	typeref:struct:s_locale
LOCALTIME	timestamp.c	68;"	d	file:
LOCK	lock.h	82;"	d
LOCKED	lock.h	86;"	d
LOCK_OBJECT	lock.h	84;"	d
LT	find.h	/^typedef enum {EQ=0,LT=1,GT=2,NE=3,LE=4,GE=5,NOT=6,BETWEEN=7,BEFORE=8,AFTER=9,SAME=10,DIFF=11,MATCH=12,LIKE=13,UNLIKE=14,FINDOP_END} FINDOP;$/;"	e	enum:__anon14
LT_OBJDIR	config.h	116;"	d
Log	complex.h	/^	inline complex Log(void) const \/**< compute log *\/$/;"	f	class:complex
MACHINEMODULATIONTYPE	loadshape.h	/^} MACHINEMODULATIONTYPE;$/;"	t	typeref:enum:__anon22
MACHINEPULSETYPE	loadshape.h	/^} MACHINEPULSETYPE; \/**< the type of pulses generated by the machine *\/$/;"	t	typeref:enum:__anon21
MACHINESTATE	loadshape.h	/^} MACHINESTATE;$/;"	t	typeref:enum:__anon23
MACHINETYPE	loadshape.h	/^} MACHINETYPE; \/** type of machine *\/$/;"	t	typeref:enum:__anon20
MACRO	load.c	154;"	d	file:
MACRO	load.c	157;"	d	file:
MATCH	find.h	/^typedef enum {EQ=0,LT=1,GT=2,NE=3,LE=4,GE=5,NOT=6,BETWEEN=7,BEFORE=8,AFTER=9,SAME=10,DIFF=11,MATCH=12,LIKE=13,UNLIKE=14,FINDOP_END} FINDOP;$/;"	e	enum:__anon14
MATLABDATETIME	cmex.c	41;"	d	file:
MAX	cmex.h	61;"	d
MAXBLOCKS	schedule.h	38;"	d
MAXNAME	cmex.c	40;"	d	file:
MAXNAME	cmex.h	29;"	d
MAXSTR	server.c	30;"	d	file:
MAXVALUES	schedule.h	39;"	d
MAXYEAR	timestamp.h	42;"	d
MAX_TABLES	gui.c	469;"	d	file:
MEXHANDLETYPE	cmex.c	/^typedef enum {MH_GLOBAL=0x19c3, MH_OBJECT=0x82a3, MH_CLASS=0x5d37, MH_MODULE=0xb40f} MEXHANDLETYPE; \/* number carefully chosen to mean nothing *\/$/;"	t	typeref:enum:__anon48	file:
MH_CLASS	cmex.c	/^typedef enum {MH_GLOBAL=0x19c3, MH_OBJECT=0x82a3, MH_CLASS=0x5d37, MH_MODULE=0xb40f} MEXHANDLETYPE; \/* number carefully chosen to mean nothing *\/$/;"	e	enum:__anon48	file:
MH_GLOBAL	cmex.c	/^typedef enum {MH_GLOBAL=0x19c3, MH_OBJECT=0x82a3, MH_CLASS=0x5d37, MH_MODULE=0xb40f} MEXHANDLETYPE; \/* number carefully chosen to mean nothing *\/$/;"	e	enum:__anon48	file:
MH_MODULE	cmex.c	/^typedef enum {MH_GLOBAL=0x19c3, MH_OBJECT=0x82a3, MH_CLASS=0x5d37, MH_MODULE=0xb40f} MEXHANDLETYPE; \/* number carefully chosen to mean nothing *\/$/;"	e	enum:__anon48	file:
MH_OBJECT	cmex.c	/^typedef enum {MH_GLOBAL=0x19c3, MH_OBJECT=0x82a3, MH_CLASS=0x5d37, MH_MODULE=0xb40f} MEXHANDLETYPE; \/* number carefully chosen to mean nothing *\/$/;"	e	enum:__anon48	file:
MICROSECOND	timestamp.c	49;"	d	file:
MIN	cmex.h	62;"	d
MINUTE	timestamp.c	47;"	d	file:
MINYEAR	timestamp.h	41;"	d
MMT_AMPLITUDE	loadshape.h	/^	MMT_AMPLITUDE=1, \/**< amplitude modulation *\/$/;"	e	enum:__anon22
MMT_FREQUENCY	loadshape.h	/^	MMT_FREQUENCY=3, \/**< frequency modulation *\/$/;"	e	enum:__anon22
MMT_PULSEWIDTH	loadshape.h	/^	MMT_PULSEWIDTH=2, \/**< pulse-width modulation *\/$/;"	e	enum:__anon22
MMT_UNKNOWN	loadshape.h	/^	MMT_UNKNOWN=0,	\/**< unspecified modulation *\/$/;"	e	enum:__anon22
MODULE	class.h	/^typedef struct s_module_list MODULE;$/;"	t	typeref:struct:s_module_list
MODULE	module.h	/^typedef struct s_module_list MODULE;$/;"	t	typeref:struct:s_module_list
MODULENAME	gridlabd.h	102;"	d
MODULE_PROP	load_xml_handle.h	/^	MODULE_PROP,	\/\/	setting a module property$/;"	e	enum:__anon30
MODULE_STATE	load_xml_handle.h	/^	MODULE_STATE,	\/\/	in a module$/;"	e	enum:__anon30
MPT_POWER	loadshape.h	/^	MPT_POWER,		\/**< pulses are of fixed power; duration is energy\/power *\/$/;"	e	enum:__anon21
MPT_TIME	loadshape.h	/^	MPT_TIME,		\/**< pulses are of fixed time (either total period or on-time duration); power is energy\/duration *\/$/;"	e	enum:__anon21
MPT_UNKNOWN	loadshape.h	/^	MPT_UNKNOWN=0,$/;"	e	enum:__anon21
MS_OFF	loadshape.h	/^	MS_OFF=0,$/;"	e	enum:__anon23
MS_ON	loadshape.h	/^	MS_ON=1,$/;"	e	enum:__anon23
MS_RAMPDOWN	loadshape.h	/^	MS_RAMPDOWN=3,$/;"	e	enum:__anon23
MS_RAMPUP	loadshape.h	/^	MS_RAMPUP=2,$/;"	e	enum:__anon23
MT_ANALOG	loadshape.h	/^	MT_ANALOG,		\/**< machine output an analog signal *\/$/;"	e	enum:__anon20
MT_MODULATED	loadshape.h	/^	MT_MODULATED,	\/**< machine outputs pulses of fixed frequency with varying area to match value *\/$/;"	e	enum:__anon20
MT_PULSED	loadshape.h	/^	MT_PULSED,		\/**< machine outputs pulses of fixed area with varying frequency to match value *\/$/;"	e	enum:__anon20
MT_QUEUED	loadshape.h	/^	MT_QUEUED,		\/**< machine accrues values and output pulses of fixed area with varying frequency *\/$/;"	e	enum:__anon20
MT_SCHEDULED	loadshape.h	/^	MT_SCHEDULED,	\/**< machine output values on a schedule *\/$/;"	e	enum:__anon20
MT_UNKNOWN	loadshape.h	/^	MT_UNKNOWN=0,$/;"	e	enum:__anon20
MWPBTUPH	cmex.h	50;"	d
MYPARENT	object.h	323;"	d
Mag	complex.h	/^	inline double Mag(double m)  \/**< set magnitude *\/$/;"	f	class:complex
Mag	complex.h	/^	inline double Mag(void) const \/**< compute magnitude *\/$/;"	f	class:complex
NAMEOBJ	load.c	3954;"	d	file:
NAMESPACE	object.h	/^} NAMESPACE;$/;"	t	typeref:struct:s_namespace
NATIVE	platform.h	55;"	d
NATIVE	platform.h	57;"	d
NE	find.h	/^typedef enum {EQ=0,LT=1,GT=2,NE=3,LE=4,GE=5,NOT=6,BETWEEN=7,BEFORE=8,AFTER=9,SAME=10,DIFF=11,MATCH=12,LIKE=13,UNLIKE=14,FINDOP_END} FINDOP;$/;"	e	enum:__anon14
NM_POSTUPDATE	class.h	/^	NM_POSTUPDATE = 1, \/**< notify module after property change *\/$/;"	e	enum:__anon5
NM_PREUPDATE	class.h	/^	NM_PREUPDATE = 0, \/**< notify module before property change *\/$/;"	e	enum:__anon5
NM_RESET	class.h	/^	NM_RESET = 2,\/**< notify module of system reset event *\/$/;"	e	enum:__anon5
NONE	cmex.c	93;"	d	file:
NORMALRES	timestamp.h	15;"	d
NOT	find.h	/^typedef enum {EQ=0,LT=1,GT=2,NE=3,LE=4,GE=5,NOT=6,BETWEEN=7,BEFORE=8,AFTER=9,SAME=10,DIFF=11,MATCH=12,LIKE=13,UNLIKE=14,FINDOP_END} FINDOP;$/;"	e	enum:__anon14
NOTIFYMODULE	class.h	/^} NOTIFYMODULE; \/**< notification message types *\/$/;"	t	typeref:enum:__anon5
NYEARS	timestamp.c	859;"	d	file:
Notation	complex.h	/^	inline CNOTATION & Notation(void) \/**< access to notation *\/$/;"	f	class:complex
OBJECT	object.h	/^} OBJECT; \/**< Object header structure *\/$/;"	t	typeref:struct:s_object_list
OBJECTDATA	object.h	320;"	d
OBJECTHDR	object.h	322;"	d
OBJECTNAME	object.h	/^typedef char * OBJECTNAME; \/** Object name *\/$/;"	t
OBJECTNUM	object.h	/^typedef unsigned int OBJECTNUM; \/** Object id number *\/$/;"	t
OBJECTRANK	object.h	/^typedef unsigned int OBJECTRANK; \/**< Object rank number *\/$/;"	t
OBJECTSIZE	object.h	/^typedef unsigned short OBJECTSIZE; \/** Object data size *\/$/;"	t
OBJECTTREE	object.c	/^} OBJECTTREE;$/;"	t	typeref:struct:s_objecttree	file:
OBJECT_PROP	load_xml_handle.h	/^	OBJECT_PROP,	\/\/	setting an object property$/;"	e	enum:__anon30
OBJECT_STATE	load_xml_handle.h	/^	OBJECT_STATE,	\/\/	setting up an object$/;"	e	enum:__anon30
OFFSET	find.c	1011;"	d	file:
OF_FOREIGN	object.h	33;"	d
OF_HASPLC	object.h	30;"	d
OF_LOCKED	object.h	31;"	d
OF_NONE	object.h	29;"	d
OF_RECALC	object.h	32;"	d
OF_RERANK	object.h	35;"	d
OF_SKIPSAFE	object.h	34;"	d
OK	stream.c	66;"	d	file:
OP_ABS	load.c	1677;"	d	file:
OP_ADD	load.c	1672;"	d	file:
OP_CLOSE	load.c	1667;"	d	file:
OP_COS	load.c	1675;"	d	file:
OP_DIV	load.c	1671;"	d	file:
OP_END	load.c	1665;"	d	file:
OP_MOD	load.c	1670;"	d	file:
OP_MULT	load.c	1669;"	d	file:
OP_OPEN	load.c	1666;"	d	file:
OP_POW	load.c	1668;"	d	file:
OP_SIN	load.c	1674;"	d	file:
OP_SUB	load.c	1673;"	d	file:
OP_TAN	load.c	1676;"	d	file:
OR	find.c	780;"	d	file:
OR	find.h	/^typedef enum {OR=-2,AND=-1,FT_END=0, FT_ID=1, FT_SIZE=2, FT_CLASS=3, FT_PARENT=4, FT_RANK=5, FT_CLOCK=6, FT_PROPERTY=7, FT_NAME=8,$/;"	e	enum:__anon15
OR	load.c	1098;"	d	file:
OUTPUT	enduse.c	170;"	d	file:
OUTPUT_NZ	enduse.c	169;"	d	file:
PACKAGE	config.h	119;"	d
PACKAGE_BUGREPORT	config.h	122;"	d
PACKAGE_NAME	config.h	125;"	d
PACKAGE_STRING	config.h	128;"	d
PACKAGE_TARNAME	config.h	131;"	d
PACKAGE_URL	config.h	134;"	d
PACKAGE_VERSION	config.h	137;"	d
PADDR	gridlabd.h	161;"	d
PARSER	find.c	776;"	d	file:
PARSER	load.c	1094;"	d	file:
PASSCMP	exec.c	132;"	d	file:
PASSCMP	save.c	178;"	d	file:
PASSCONFIG	class.h	/^typedef unsigned char PASSCONFIG; \/**< the pass configuration *\/$/;"	t
PASSINC	exec.c	133;"	d	file:
PASSINC	save.c	179;"	d	file:
PASSINIT	exec.c	131;"	d	file:
PASSINIT	save.c	177;"	d	file:
PASS_OP	load.c	1681;"	d	file:
PATHSEP	globals.c	102;"	d	file:
PATHSEP	globals.c	108;"	d	file:
PATHSEP	load.c	489;"	d	file:
PA_PRIVATE	class.h	/^	PA_PRIVATE, \/**< property is nonpublic (not-visible, saved or loaded) *\/$/;"	e	enum:__anon4
PA_PROTECTED	class.h	/^	PA_PROTECTED, \/**< property is semipublic (visible, but not saved or loaded) *\/$/;"	e	enum:__anon4
PA_PUBLIC	class.h	/^	PA_PUBLIC, \/**< property is public (visible, saved, and loaded) *\/$/;"	e	enum:__anon4
PA_REFERENCE	class.h	/^	PA_REFERENCE, \/**< property is FYI (visible and saved, but not loaded *\/$/;"	e	enum:__anon4
PC_BOTTOMUP	class.h	129;"	d
PC_FORCE_NAME	class.h	131;"	d
PC_NOSYNC	class.h	127;"	d
PC_PARENT_OVERRIDE_OMIT	class.h	132;"	d
PC_POSTTOPDOWN	class.h	130;"	d
PC_PRETOPDOWN	class.h	128;"	d
PC_UNSAFE_OVERRIDE_OMIT	class.h	133;"	d
PF_CHARSET	class.h	149;"	d
PF_DEPRECATED	class.h	151;"	d
PF_DEPRECATED_NONOTICE	class.h	152;"	d
PF_RECALC	class.h	148;"	d
PGMCONSTFLAGS	find.h	/^typedef unsigned int PGMCONSTFLAGS; \/**< find program constant criteria flags *\/$/;"	t
PI	complex.h	23;"	d
PI	unit.c	724;"	d	file:
PRINTFUNCTION	output.h	/^typedef int (*PRINTFUNCTION)(char *,...);$/;"	t
PROPERTY	class.h	/^} PROPERTY; \/**< property definition item *\/$/;"	t	typeref:struct:s_property_map
PROPERTY	cmex.h	/^} PROPERTY;$/;"	t	typeref:struct:__anon10
PROPERTYACCESS	class.h	/^} PROPERTYACCESS; \/**< property access rights *\/$/;"	t	typeref:enum:__anon4
PROPERTYADDR	class.h	/^typedef void* PROPERTYADDR; \/**< the offset of a property from the end of the OBJECT header *\/$/;"	t
PROPERTYFLAGS	class.h	/^typedef unsigned long PROPERTYFLAGS;$/;"	t
PROPERTYNAME	class.h	/^typedef char PROPERTYNAME[64]; \/**< the name of a property *\/$/;"	t
PROPERTYTYPE	class.h	/^} PROPERTYTYPE; \/**< property types *\/$/;"	t	typeref:enum:__anon3
PROPERTYTYPE	cmex.h	/^typedef enum {INTEGER, REAL} PROPERTYTYPE;$/;"	t	typeref:enum:__anon9
PT_ACCESS	class.h	/^	PT_ACCESS, \/* used to specify property access rights *\/$/;"	e	enum:__anon3
PT_AGGREGATE	class.h	/^	PT_AGGREGATE, \/* internal use only *\/$/;"	e	enum:__anon3
PT_DEPRECATED	class.h	/^	PT_DEPRECATED, \/* used to flag a property that is deprecated *\/$/;"	e	enum:__anon3
PT_DESCRIPTION	class.h	/^	PT_DESCRIPTION, \/* used to provide helpful description of property *\/$/;"	e	enum:__anon3
PT_EXTEND	class.h	/^	PT_EXTEND, \/* used to enlarge class size by the size of the current property being mapped *\/$/;"	e	enum:__anon3
PT_EXTENDBY	class.h	/^	PT_EXTENDBY, \/* used to enlarge class size by the size provided in the next argument *\/$/;"	e	enum:__anon3
PT_EXTENDED	class.h	150;"	d
PT_FLAGS	class.h	/^	PT_FLAGS, \/* used to indicate property flags next *\/$/;"	e	enum:__anon3
PT_INHERIT	class.h	/^	PT_INHERIT, \/* used to indicate that properties from a parent class are to be published *\/$/;"	e	enum:__anon3
PT_KEYWORD	class.h	/^	PT_KEYWORD, \/* used to add an enum\/set keyword definition *\/$/;"	e	enum:__anon3
PT_SIZE	class.h	/^	PT_SIZE, \/* used to setup arrayed properties *\/$/;"	e	enum:__anon3
PT_UNITS	class.h	/^	PT_UNITS, \/* used to indicate that property has certain units (which following immediately as a string) *\/$/;"	e	enum:__anon3
PT_bool	class.h	/^	PT_bool, \/**< the data is a true\/false value, implemented as a C++ bool *\/$/;"	e	enum:__anon3
PT_char1024	class.h	/^	PT_char1024, \/**< the data is \\p NULL -terminated string up to 1024 characters in length *\/$/;"	e	enum:__anon3
PT_char256	class.h	/^	PT_char256, \/**< the data is \\p NULL -terminated string up to 256 characters in length *\/$/;"	e	enum:__anon3
PT_char32	class.h	/^	PT_char32, \/**< the data is \\p NULL -terminated string up to 32 characters in length *\/ $/;"	e	enum:__anon3
PT_char8	class.h	/^	PT_char8, \/**< the data is \\p NULL -terminated string up to 8 characters in length *\/$/;"	e	enum:__anon3
PT_complex	class.h	/^	PT_complex, \/**< the data is a complex value *\/$/;"	e	enum:__anon3
PT_complex_array	class.h	/^	PT_complex_array, \/**< the data is a fixed length complex[] *\/$/;"	e	enum:__anon3
PT_delegated	class.h	/^	PT_delegated, \/**< the data is delegated to a module for implementation *\/$/;"	e	enum:__anon3
PT_double	class.h	/^	PT_double, \/**< the data is a double-precision float *\/$/;"	e	enum:__anon3
PT_double_array	class.h	/^	PT_double_array, \/**< the data is a fixed length double[] *\/$/;"	e	enum:__anon3
PT_enduse	class.h	/^	PT_enduse,		\/**< Enduse load data *\/$/;"	e	enum:__anon3
PT_enumeration	class.h	/^	PT_enumeration, \/**< the data is an enumeration *\/$/;"	e	enum:__anon3
PT_float	class.h	/^	PT_float,	\/**< Single-precision float	*\/$/;"	e	enum:__anon3
PT_int16	class.h	/^	PT_int16, \/**< the data is a 16-bit integer *\/$/;"	e	enum:__anon3
PT_int32	class.h	/^	PT_int32, \/**< the data is a 32-bit integer *\/$/;"	e	enum:__anon3
PT_int64	class.h	/^	PT_int64, \/**< the data is a 64-bit integer *\/$/;"	e	enum:__anon3
PT_loadshape	class.h	/^	PT_loadshape,	\/**< Loadshapes are state machines driven by schedules *\/$/;"	e	enum:__anon3
PT_object	class.h	/^	PT_object, \/**< the data is a pointer to a GridLAB object *\/$/;"	e	enum:__anon3
PT_real	class.h	/^	PT_real,	\/**< Single or double precision float ~ allows double values to be overriden *\/$/;"	e	enum:__anon3
PT_set	class.h	/^	PT_set, \/**< the data is a set *\/$/;"	e	enum:__anon3
PT_timestamp	class.h	/^	PT_timestamp, \/**< timestamp value *\/$/;"	e	enum:__anon3
PT_triple	class.h	/^	PT_triple, \/**< triplet of doubles (not supported) *\/$/;"	e	enum:__anon3
PT_triplex	class.h	/^	PT_triplex, \/**< triplet of complexes (not supported) *\/$/;"	e	enum:__anon3
PT_void	class.h	/^	PT_void, \/**< the type has no data *\/$/;"	e	enum:__anon3
PUBLISH_CLASS	gridlabd.h	139;"	d
PUBLISH_CLASSX	gridlabd.h	142;"	d
PUBLISH_DELEGATED	gridlabd.h	150;"	d
PUBLISH_STRUCT	gridlabd.h	136;"	d
PUTC	stream.c	39;"	d	file:
PUTC	stream.c	50;"	d	file:
PUTD	stream.c	38;"	d	file:
PUTD	stream.c	49;"	d	file:
PUTL	stream.c	41;"	d	file:
PUTL	stream.c	52;"	d	file:
PUTQ	stream.c	42;"	d	file:
PUTQ	stream.c	53;"	d	file:
PUTS	stream.c	40;"	d	file:
PUTS	stream.c	51;"	d	file:
PUTT	stream.c	44;"	d	file:
PUTT	stream.c	55;"	d	file:
PUTX	stream.c	43;"	d	file:
PUTX	stream.c	54;"	d	file:
QNAN	load.c	173;"	d	file:
QNAN	object.c	48;"	d	file:
QNAN	random.c	35;"	d	file:
QNAN	schedule.c	22;"	d	file:
R	complex.h	/^typedef enum {I='i',J='j',A='d', R='r'} CNOTATION; \/**< complex number notation to use *\/$/;"	e	enum:__anon12
RANDOMTYPE	random.h	/^} RANDOMTYPE;$/;"	t	typeref:enum:__anon46
RANDU	cmex.h	53;"	d
REAL	cmex.h	/^typedef enum {INTEGER, REAL} PROPERTYTYPE;$/;"	e	enum:__anon9
REALTIME_LDFLAGS	config.h	144;"	d
REALTIME_LDFLAGS	load.c	135;"	d	file:
REJECT	find.c	781;"	d	file:
REJECT	load.c	1099;"	d	file:
REPEAT	load.c	1107;"	d	file:
REV_MAJOR	version.h	6;"	d
REV_MINOR	version.h	7;"	d
REV_PATCH	version.h	8;"	d
RHOWATER	cmex.h	46;"	d
RT_BERNOULLI	random.h	/^	RT_BERNOULLI,	\/**< Bernoulli distribution; double probability_of_observing_1 *\/$/;"	e	enum:__anon46
RT_BETA	random.h	/^	RT_BETA,		\/**< Beta distribution; double alpha, double beta *\/$/;"	e	enum:__anon46
RT_DEGENERATE	random.h	/^	RT_DEGENERATE,	\/**< degenerate distribution (Dirac delta function); double only_value *\/$/;"	e	enum:__anon46
RT_EXPONENTIAL	random.h	/^	RT_EXPONENTIAL, \/**< exponential distribution; double coefficient, double k_scale *\/$/;"	e	enum:__anon46
RT_GAMMA	random.h	/^	RT_GAMMA,		\/**< Gamma distribution; double alpha, double beta *\/$/;"	e	enum:__anon46
RT_INVALID	random.h	/^	RT_INVALID=-1,	\/**< used to flag bad random types *\/$/;"	e	enum:__anon46
RT_LOGNORMAL	random.h	/^	RT_LOGNORMAL,	\/**< log-normal distribution; double geometric_mean, double geometric_stdev *\/$/;"	e	enum:__anon46
RT_NORMAL	random.h	/^	RT_NORMAL,		\/**< normal distribution; double arithmetic_mean, double arithmetic_stdev *\/$/;"	e	enum:__anon46
RT_PARETO	random.h	/^	RT_PARETO,		\/**< Pareto distribution; double minimum_value, double gamma_scale *\/$/;"	e	enum:__anon46
RT_RAYLEIGH	random.h	/^	RT_RAYLEIGH,	\/**< Rayleigh distribution; double sigma *\/$/;"	e	enum:__anon46
RT_SAMPLED	random.h	/^	RT_SAMPLED,		\/**< sampled distribution; unsigned number_of_samples, double samples[n_samples] *\/$/;"	e	enum:__anon46
RT_TRIANGLE	random.h	/^	RT_TRIANGLE,	\/**< Triangle distribution; double a, double b *\/$/;"	e	enum:__anon46
RT_UNIFORM	random.h	/^	RT_UNIFORM,		\/**< uniform distribution; double minimum_value, double maximum_value *\/$/;"	e	enum:__anon46
RT_WEIBULL	random.h	/^	RT_WEIBULL,		\/**< Weibull distribution; double lambda, double k *\/$/;"	e	enum:__anon46
R_OK	platform.h	32;"	d
Re	complex.h	/^	inline double & Re(void) \/**< access to real part *\/$/;"	f	class:complex
SAME	find.h	/^typedef enum {EQ=0,LT=1,GT=2,NE=3,LE=4,GE=5,NOT=6,BETWEEN=7,BEFORE=8,AFTER=9,SAME=10,DIFF=11,MATCH=12,LIKE=13,UNLIKE=14,FINDOP_END} FINDOP;$/;"	e	enum:__anon14
SB_BEGIN	stream.c	/^	SB_BEGIN=0x00,$/;"	e	enum:__anon56	file:
SB_CLASS	stream.c	/^	SB_CLASS,$/;"	e	enum:__anon56	file:
SB_END	stream.c	/^	SB_END=0xff,$/;"	e	enum:__anon56	file:
SB_GLOBAL	stream.c	/^	SB_GLOBAL,$/;"	e	enum:__anon56	file:
SB_KEYWORD	stream.c	/^	SB_KEYWORD,$/;"	e	enum:__anon56	file:
SB_MODULE	stream.c	/^	SB_MODULE,$/;"	e	enum:__anon56	file:
SB_OBJECT	stream.c	/^	SB_OBJECT,$/;"	e	enum:__anon56	file:
SB_PROPERTY	stream.c	/^	SB_PROPERTY,$/;"	e	enum:__anon56	file:
SB_SCHEDULE	stream.c	/^	SB_SCHEDULE,$/;"	e	enum:__anon56	file:
SB_TRANSFORM	stream.c	/^	SB_TRANSFORM,$/;"	e	enum:__anon56	file:
SB_UNIT	stream.c	/^	SB_UNIT,$/;"	e	enum:__anon56	file:
SCHEDULE	schedule.h	/^typedef struct s_schedule SCHEDULE;$/;"	t	typeref:struct:s_schedule
SCHEDULEINDEX	schedule.h	/^typedef uint32 SCHEDULEINDEX;$/;"	t
SCHEDULEXFORM	schedule.h	/^} SCHEDULEXFORM;$/;"	t	typeref:struct:s_schedulexform
SECOND	timestamp.c	48;"	d	file:
SET_ADD	class.h	178;"	d
SET_CALENDAR	schedule.h	46;"	d
SET_CLEAR	class.h	180;"	d
SET_DEL	class.h	179;"	d
SET_HAS	class.h	181;"	d
SET_MASK	class.h	177;"	d
SET_MINUTE	schedule.h	47;"	d
SF_ALL	stream.h	17;"	d
SF_CLASSES	stream.h	15;"	d
SF_GLOBALS	stream.h	14;"	d
SF_MODULES	stream.h	13;"	d
SF_OBJECTS	stream.h	16;"	d
SIZE	find.c	287;"	d	file:
SN_ABSOLUTE	schedule.h	97;"	d
SN_BOOLEAN	schedule.h	99;"	d
SN_NONZERO	schedule.h	100;"	d
SN_NORMAL	schedule.h	96;"	d
SN_POSITIVE	schedule.h	101;"	d
SN_WEIGHTED	schedule.h	98;"	d
SOCKET	server.c	20;"	d	file:
SPEC	timestamp.c	/^} SPEC; \/**< the specification of a DST event *\/$/;"	t	typeref:struct:__anon60	file:
START	find.c	777;"	d	file:
START	load.c	1095;"	d	file:
STAT	load.c	/^typedef struct _stat STAT;$/;"	t	typeref:struct:_stat	file:
STAT	load.c	/^typedef struct stat STAT;$/;"	t	typeref:struct:stat	file:
STATUS	globals.h	/^typedef enum {FAILED=FALSE, SUCCESS=TRUE} STATUS;$/;"	t	typeref:enum:__anon17
STDC_HEADERS	config.h	147;"	d
STREAM_NAME	stream.c	14;"	d	file:
STREAM_VERSION	stream.c	17;"	d	file:
STRING_LIST	object.h	/^} STRING_LIST;$/;"	t	typeref:struct:string_linked_list
ST_ACCESS	stream.c	/^	ST_ACCESS,$/;"	e	enum:__anon57	file:
ST_BEGIN	stream.c	/^	ST_BEGIN=0x00,$/;"	e	enum:__anon57	file:
ST_BIAS	stream.c	/^	ST_BIAS,$/;"	e	enum:__anon57	file:
ST_CLASS	stream.c	/^	ST_CLASS,$/;"	e	enum:__anon57	file:
ST_CLOCK	stream.c	/^	ST_CLOCK,$/;"	e	enum:__anon57	file:
ST_DATA	stream.c	/^	ST_DATA,$/;"	e	enum:__anon57	file:
ST_DEFINITION	stream.c	/^	ST_DEFINITION,$/;"	e	enum:__anon57	file:
ST_END	stream.c	/^	ST_END=0xff,$/;"	e	enum:__anon57	file:
ST_FLAGS	stream.c	/^	ST_FLAGS,$/;"	e	enum:__anon57	file:
ST_GLOBAL	stream.c	/^	ST_GLOBAL,$/;"	e	enum:__anon57	file:
ST_GROUP	stream.c	/^	ST_GROUP,$/;"	e	enum:__anon57	file:
ST_ID	stream.c	/^	ST_ID,$/;"	e	enum:__anon57	file:
ST_INSVC	stream.c	/^	ST_INSVC,$/;"	e	enum:__anon57	file:
ST_KEYWORD	stream.c	/^	ST_KEYWORD,$/;"	e	enum:__anon57	file:
ST_LATITUDE	stream.c	/^	ST_LATITUDE,$/;"	e	enum:__anon57	file:
ST_LONGITUDE	stream.c	/^	ST_LONGITUDE,$/;"	e	enum:__anon57	file:
ST_MODULE	stream.c	/^	ST_MODULE,$/;"	e	enum:__anon57	file:
ST_NAME	stream.c	/^	ST_NAME,$/;"	e	enum:__anon57	file:
ST_OBJECT	stream.c	/^	ST_OBJECT,$/;"	e	enum:__anon57	file:
ST_OUTSVC	stream.c	/^	ST_OUTSVC,$/;"	e	enum:__anon57	file:
ST_PARENT	stream.c	/^	ST_PARENT,$/;"	e	enum:__anon57	file:
ST_PROPERTY	stream.c	/^	ST_PROPERTY,$/;"	e	enum:__anon57	file:
ST_RANK	stream.c	/^	ST_RANK,$/;"	e	enum:__anon57	file:
ST_SCALE	stream.c	/^	ST_SCALE,$/;"	e	enum:__anon57	file:
ST_SCHEDULE	stream.c	/^	ST_SCHEDULE,$/;"	e	enum:__anon57	file:
ST_SIZE	stream.c	/^	ST_SIZE,$/;"	e	enum:__anon57	file:
ST_TRANSFORM	stream.c	/^	ST_TRANSFORM,$/;"	e	enum:__anon57	file:
ST_TYPE	stream.c	/^	ST_TYPE,$/;"	e	enum:__anon57	file:
ST_UNIT	stream.c	/^	ST_UNIT,$/;"	e	enum:__anon57	file:
ST_VALIDTO	stream.c	/^	ST_VALIDTO,$/;"	e	enum:__anon57	file:
ST_VALUE	stream.c	/^	ST_VALUE,$/;"	e	enum:__anon57	file:
ST_VERSION	stream.c	/^	ST_VERSION,$/;"	e	enum:__anon57	file:
SUCCESS	globals.h	/^typedef enum {FAILED=FALSE, SUCCESS=TRUE} STATUS;$/;"	e	enum:__anon17
SetImag	complex.h	/^	inline void SetImag(double v) \/**< set imaginary part *\/$/;"	f	class:complex
SetNotation	complex.h	/^	inline void SetNotation(CNOTATION nf) \/**< set notation *\/$/;"	f	class:complex
SetPolar	complex.h	/^	inline void SetPolar(double m, double a, CNOTATION nf=A) \/**< set polar values *\/$/;"	f	class:complex
SetPowerFactor	complex.h	/^	inline complex SetPowerFactor(double mag, \/**< magnitude of power *\/$/;"	f	class:complex
SetReal	complex.h	/^	inline void SetReal(double v) \/**< set real part *\/$/;"	f	class:complex
SetRect	complex.h	/^	inline void SetRect(double rp, double ip, CNOTATION nf=CNOTATION_DEFAULT) \/**< set rectangular value *\/$/;"	f	class:complex
T	stream.c	68;"	d	file:
TABLEOPTIONS	gui.c	25;"	d	file:
TABLEOPTIONS	gui.c	27;"	d	file:
TERM	find.c	784;"	d	file:
TERM	load.c	1103;"	d	file:
TEST_CALLBACKS	test_callbacks.h	/^} TEST_CALLBACKS;$/;"	t	typeref:struct:s_test_callbacks
THROW	exception.h	22;"	d
TIMESTAMP	timestamp.h	/^typedef int64 TIMESTAMP;$/;"	t
TIME_WITH_SYS_TIME	config.h	150;"	d
TMP	globals.c	101;"	d	file:
TMP	globals.c	107;"	d	file:
TRACE	cmex.h	33;"	d
TRACE	cmex.h	39;"	d
TRACE1	cmex.h	34;"	d
TRACE1	cmex.h	40;"	d
TRACE2	cmex.h	35;"	d
TRACE2	cmex.h	36;"	d
TRACE2	cmex.h	41;"	d
TRACE3	cmex.h	37;"	d
TRACE3	cmex.h	42;"	d
TRUE	globals.h	27;"	d
TRY	exception.h	17;"	d
TS_INVALID	timestamp.h	39;"	d
TS_MAX	timestamp.h	38;"	d
TS_NEVER	timestamp.h	40;"	d
TS_RESOLUTION	timestamp.h	20;"	d
TS_RESOLUTION	timestamp.h	24;"	d
TS_RESOLUTION	timestamp.h	28;"	d
TS_RESOLUTION	timestamp.h	32;"	d
TS_SCALE	timestamp.h	18;"	d
TS_SCALE	timestamp.h	22;"	d
TS_SCALE	timestamp.h	26;"	d
TS_SCALE	timestamp.h	30;"	d
TS_SECOND	timestamp.h	19;"	d
TS_SECOND	timestamp.h	23;"	d
TS_SECOND	timestamp.h	27;"	d
TS_SECOND	timestamp.h	31;"	d
TS_ZERO	timestamp.h	37;"	d
TZFILE	timestamp.c	43;"	d	file:
UNIT	unit.h	/^} UNIT; \/**< the UNIT structure *\/$/;"	t	typeref:struct:s_unit
UNITSCALAR	unit.c	/^typedef struct s_unitscalar UNITSCALAR;$/;"	t	typeref:struct:s_unitscalar	file:
UNLIKE	find.h	/^typedef enum {EQ=0,LT=1,GT=2,NE=3,LE=4,GE=5,NOT=6,BETWEEN=7,BEFORE=8,AFTER=9,SAME=10,DIFF=11,MATCH=12,LIKE=13,UNLIKE=14,FINDOP_END} FINDOP;$/;"	e	enum:__anon14
UNLOCK	lock.h	83;"	d
UNLOCK_OBJECT	lock.h	85;"	d
UNRESOLVED	load.h	/^} UNRESOLVED;$/;"	t	typeref:struct:s_unresolved
UNR_FUNC	load.h	/^} UNR_FUNC;$/;"	t	typeref:struct:s_unresolved_func
UR_NONE	load.h	17;"	d
UR_RANKS	load.h	18;"	d
UR_TRANSFORM	load.h	19;"	d
USERVAR	globals.c	104;"	d	file:
USERVAR	globals.c	110;"	d	file:
VALUE	find.c	540;"	d	file:
VERSION	config.h	156;"	d
WATCHPOINT	debug.c	/^} WATCHPOINT; \/**< the structure for a watchpoint entry *\/$/;"	t	typeref:struct:s_watchpoint	file:
WHITE	find.c	782;"	d	file:
WHITE	load.c	1101;"	d	file:
WIN32_LEAN_AND_MEAN	module.c	23;"	d	file:
WIN32_LEAN_AND_MEAN	threadpool.c	22;"	d	file:
W_OK	platform.h	33;"	d
XFORMSOURCE	schedule.h	/^	} XFORMSOURCE;$/;"	t	typeref:enum:__anon47
XS_ALL	schedule.h	/^	XS_ALL		= 0x1f,$/;"	e	enum:__anon47
XS_COMPLEX	schedule.h	/^	XS_COMPLEX	= 0x02, $/;"	e	enum:__anon47
XS_DOUBLE	schedule.h	/^	XS_DOUBLE	= 0x01, $/;"	e	enum:__anon47
XS_ENDUSE	schedule.h	/^	XS_ENDUSE	= 0x08, $/;"	e	enum:__anon47
XS_LOADSHAPE	schedule.h	/^	XS_LOADSHAPE= 0x04, $/;"	e	enum:__anon47
XS_SCHEDULE	schedule.h	/^	XS_SCHEDULE = 0x10,$/;"	e	enum:__anon47
XS_UNKNOWN	schedule.h	/^	XS_UNKNOWN	= 0x00, $/;"	e	enum:__anon47
X_OK	platform.h	34;"	d
YEAR0	timestamp.c	58;"	d	file:
YEAR0_ISLY	timestamp.c	59;"	d	file:
_AGGREGATE_H	aggregate.h	9;"	d
_CLASS_H	class.h	9;"	d
_CMDARG_H	cmdarg.h	10;"	d
_COMPLEX_H	complex.h	19;"	d
_CONVERT_H	convert.h	9;"	d
_DEBUG_H	debug.h	11;"	d
_ENDUSE_H	enduse.h	3;"	d
_ENVIRONMENT_H	environment.h	10;"	d
_ERROR_H	output.h	9;"	d
_ETP_H	cmex.h	17;"	d
_EXCEPTION_H	exception.h	10;"	d
_EXEC_H	exec.h	11;"	d
_FIND_H	find.h	8;"	d
_GLOBALS_H	globals.h	8;"	d
_GRIDLABD_H	gridlabd.h	55;"	d
_GRIDLABD_VERSION_H	version.h	4;"	d
_GUI_ACTION_END	gui.h	/^	_GUI_ACTION_END, \/\/ end of action entities$/;"	e	enum:__anon19
_GUI_GROUPING_END	gui.h	/^	_GUI_GROUPING_END, \/\/ end of grouping entities$/;"	e	enum:__anon19
_GUI_H	gui.h	11;"	d
_GUI_INPUT_END	gui.h	/^	_GUI_INPUT_END, \/\/ end of input entities$/;"	e	enum:__anon19
_GUI_LABELING_END	gui.h	/^	_GUI_LABELING_END, \/\/ end of labeling entities$/;"	e	enum:__anon19
_GUI_OUTPUT_END	gui.h	/^	_GUI_OUTPUT_END, \/\/ end of output entities$/;"	e	enum:__anon19
_INDEX_H	index.h	10;"	d
_KILL_H	kill.h	5;"	d
_LEGAL_H	legal.h	7;"	d
_LIST_H	list.h	10;"	d
_LOAD_H	load.h	10;"	d
_LOCAL_H	local.h	6;"	d
_LOCK_H	lock.h	31;"	d
_MAIN_C	cmex.c	28;"	d	file:
_MAIN_C	main.c	8;"	d	file:
_MATLAB_H	matlab.h	9;"	d
_MAX_PATH	debug.c	229;"	d	file:
_MAX_PATH	exec.c	128;"	d	file:
_MODULE_DEFINED_	class.h	185;"	d
_MODULE_DEFINED_	module.h	37;"	d
_MODULE_H	module.h	6;"	d
_OBJECT_H	object.h	8;"	d
_PLATFORM_H	platform.h	13;"	d
_PT_FIRST	class.h	/^typedef enum {_PT_FIRST=-1, $/;"	e	enum:__anon3
_PT_LAST	class.h	/^	_PT_LAST, $/;"	e	enum:__anon3
_RANDOM_H	random.h	10;"	d
_REALTIME_H	realtime.h	6;"	d
_SAVE_H	save.h	6;"	d
_SCHEDULE_H	schedule.h	33;"	d
_SERVER_H	server.h	6;"	d
_SFSM_H	loadshape.h	8;"	d
_STREAM_H	stream.h	6;"	d
_TESTFRAMEWORK_H	test_framework.h	5;"	d
_TEST_CALLBACKS_H	test_callbacks.h	5;"	d
_TEST_H	test.h	7;"	d
_THREADPOOL_H	threadpool.h	10;"	d
_TIMESTAMP_H	timestamp.h	10;"	d
_UNIT_H	unit.h	10;"	d
_WIN32_WINNT	module.c	24;"	d	file:
_WIN32_WINNT	threadpool.c	23;"	d	file:
_XCORE_H	xcore.h	6;"	d
_XML_LOAD_H_	load_xml.h	20;"	d
__USE_GNU	threadpool.c	87;"	d	file:
_object_namespace	object.c	/^static int _object_namespace(NAMESPACE *space,char *buffer,int size)$/;"	f	file:
_object_sync	object.c	/^TIMESTAMP _object_sync(OBJECT *obj, \/**< the object to synchronize *\/$/;"	f
_random_value	random.c	/^static double _random_value(RANDOMTYPE type, va_list ptr)$/;"	f	file:
_real	find.c	/^static int _real(PARSER, double *value)$/;"	f	file:
_timezone	timestamp.c	40;"	d	file:
_tzname	timestamp.c	39;"	d	file:
a	unit.h	/^	double c,e,h,k,m,s,a,b; \/**< the unit parameters *\/$/;"	m	struct:s_unit
abs	schedule.h	/^	double abs[MAXBLOCKS];				\/**< the sum of the absolute values for each block -- used to normalize *\/$/;"	m	struct:s_schedule
access	class.h	/^	PROPERTYACCESS access; \/**< property access flags *\/$/;"	m	struct:s_property_map
access	globals.c	/^	PROPERTYACCESS access;$/;"	m	struct:s_varmap	file:
access	load.c	491;"	d	file:
action	gui.h	/^	char action[64]; \/\/ action value$/;"	m	struct:s_guientity
add	object.h	/^		void (*add)(struct s_findlist*, OBJECT*);$/;"	m	struct:s_callbacks::__anon34
add_pgm	find.c	/^static FINDPGM *add_pgm(FINDPGM **pgm, COMPAREFUNC op, unsigned short target, FINDVALUE value, FOUNDACTION pos, FOUNDACTION neg)$/;"	f	file:
add_to_name_list	object.c	/^void add_to_name_list(STRING_LIST *list, char * add_name, char * add_module_type, char * add_parent){$/;"	f
add_unresolved	load.c	/^\/*static*\/ UNRESOLVED *add_unresolved(OBJECT *by, PROPERTYTYPE ptype, void *ref, CLASS *oclass, char *id, char *file, unsigned int line, int flags)$/;"	f
addr	class.h	/^	FUNCTIONADDR addr;$/;"	m	struct:s_function_map
addr	class.h	/^	PROPERTYADDR addr; \/**< property location, offset from OBJECT header *\/$/;"	m	struct:s_property_map
addr	cmex.h	/^		void *addr;$/;"	m	union:__anon10::__anon11
addr	globals.c	/^	void *addr;$/;"	m	struct:s_varmap	file:
addto_tree	object.c	/^static int addto_tree(OBJECTTREE **tree, OBJECTTREE *item){$/;"	f	file:
admittance	enduse.h	/^	complex admittance;			\/* constant impedance oprtion of load in kW *\/$/;"	m	struct:s_enduse
after	object.c	/^	struct s_objecttree *before, *after;$/;"	m	struct:s_objecttree	typeref:struct:s_objecttree::	file:
aggregate_mkgroup	aggregate.c	/^AGGREGATION *aggregate_mkgroup(char *aggregator, \/**< aggregator (min,max,avg,std,sum,prod,mbe,mean,var,skew,kur,count,gamma) *\/$/;"	f
aggregate_value	aggregate.c	/^double aggregate_value(AGGREGATION *aggr) \/**< the aggregation to perform *\/$/;"	f
alternate_value	load.c	/^static int alternate_value(PARSER, char *value, int size)$/;"	f	file:
analog	loadshape.h	/^		} analog;$/;"	m	union:s_loadshape::__anon24	typeref:struct:s_loadshape::__anon24::__anon25
append_code	load.c	/^static int append_code(char* format,...)$/;"	f	file:
append_global	load.c	/^static int append_global(char* format,...)$/;"	f	file:
append_init	load.c	/^static int append_init(char* format,...)$/;"	f	file:
arg	aggregate.c	/^double arg(complex *x)$/;"	f
arg_data	exec.c	/^struct arg_data {$/;"	s	file:
args	load.c	/^	int args; \/* use a mode instead? else assume only doubles *\/$/;"	m	struct:s_rpn_func	file:
argument_list	load.c	/^static int argument_list(PARSER, char *args, int size)$/;"	f	file:
array	object.h	/^		OBJECT *(*array)(CLASS*,unsigned int);$/;"	m	struct:s_callbacks::__anon31
at	realtime.c	/^	time_t at;$/;"	m	struct:s_eventlist	file:
atoi64	platform.h	21;"	d
atoi64	platform.h	44;"	d
atomic_compare_and_swap	lock.h	38;"	d
atomic_compare_and_swap	lock.h	53;"	d
atomic_compare_and_swap	lock.h	59;"	d
atomic_increment	lock.h	/^		static inline unsigned int atomic_increment(unsigned int *ptr)$/;"	f
atomic_increment	lock.h	40;"	d
atomic_increment	lock.h	54;"	d
atomic_increment	lock.h	60;"	d
b	stream.c	/^static unsigned char b,t;$/;"	v	file:
b	unit.h	/^	double c,e,h,k,m,s,a,b; \/**< the unit parameters *\/$/;"	m	struct:s_unit
balance	object.c	/^	int balance; \/* unused *\/$/;"	m	struct:s_objecttree	file:
before	object.c	/^	struct s_objecttree *before, *after;$/;"	m	struct:s_objecttree	typeref:struct:s_objecttree::s_objecttree	file:
bernoulli	object.h	/^		double (*bernoulli)(double p);$/;"	m	struct:s_callbacks::__anon35
beta	object.h	/^		double (*beta)(double a, double b);$/;"	m	struct:s_callbacks::__anon35
bias	schedule.h	/^	double bias;$/;"	m	struct:s_schedulexform
bitof	gridlabd.h	/^inline char bitof(unsigned int64 x,\/**< bit pattern to scan *\/$/;"	f
block	schedule.h	/^	unsigned char block;				\/**< the last block used (4 max) *\/$/;"	m	struct:s_schedule
blockname	schedule.h	/^	char blockname[MAXBLOCKS][64];		\/**< the name of each block *\/$/;"	m	struct:s_schedule
bool	class.h	/^typedef unsigned char bool;$/;"	t
breaker_amps	enduse.h	/^	double breaker_amps;		\/* breaker limit (if any) *\/$/;"	m	struct:s_enduse
breakpoint_count	debug.c	/^static int breakpoint_count=0; \/**< the number of breakpoints defined so far *\/$/;"	v	file:
brief	cmex.c	/^	char *brief;$/;"	m	struct:__anon49	file:
buf	exception.h	/^	jmp_buf buf; \/**< the \\p jmpbuf containing the context for the exception handler *\/$/;"	m	struct:s_exception_handler
buffer	debug.c	/^	char buffer[4096]; \/**< the current value being watched *\/$/;"	m	struct:s_watchpoint	file:
buffer	output.c	/^static char buffer[65536];$/;"	v	file:
buffer	server.c	/^    char *buffer;$/;"	m	struct:s_http	file:
buffer_read	load.c	/^static int buffer_read(FILE *fp, char *buffer, char *filename, int size)$/;"	f	file:
buffer_read_alt	load.c	/^static int buffer_read_alt(FILE *fp, char *buffer, char *filename, int size)$/;"	f	file:
buffer_write	class.c	/^static int buffer_write(char *buffer, size_t len, char *format, ...){$/;"	f	file:
buildtmp	globals.c	/^static void buildtmp(void)$/;"	f	file:
by	load.h	/^	OBJECT *by;$/;"	m	struct:s_unresolved
c	stream.c	/^static unsigned char c;$/;"	v	file:
c	unit.c	/^static double c = 2.997925e8;		\/**< m\/s *\/$/;"	v	file:
c	unit.h	/^	double c,e,h,k,m,s,a,b; \/**< the unit parameters *\/$/;"	m	struct:s_unit
call	cmex.c	/^	void (*call)(int, mxArray*[],int,const mxArray*[]);$/;"	m	struct:__anon49	file:
call	realtime.c	/^	STATUS (*call)(void);$/;"	m	struct:s_eventlist	file:
callback	globals.c	/^	void (*callback)(char *name);$/;"	m	struct:s_varmap	file:
callback	globals.h	/^	void (*callback)(char *); \/\/ this function will be called whenever the globalvar is set$/;"	m	struct:s_globalvar
callbacks	module.c	/^static CALLBACKS callbacks = {$/;"	v	file:
callbacks	test.c	/^static TEST_CALLBACKS callbacks = {$/;"	v	file:
char1024	class.h	/^typedef char char1024[1025]; \/**< strings up to 1024 characters *\/$/;"	t
char256	class.h	/^typedef char char256[257]; \/**< strings up to 256 characters *\/$/;"	t
char32	class.h	/^typedef char char32[33]; \/**< strings up to 32 characters *\/$/;"	t
char8	class.h	/^typedef char char8[9]; \/** string up to 8 characters *\/$/;"	t
check	class.c	/^static int check = 0;  \/* there must be a better way to do this, but this works. -MH *\/$/;"	v	file:
check	module.h	/^	int (*check)();$/;"	m	struct:s_module_list
class_add_extended_property	class.c	/^PROPERTY *class_add_extended_property(CLASS *oclass, char *name, PROPERTYTYPE ptype, char *unit)$/;"	f
class_add_property	class.c	/^void class_add_property(CLASS *oclass, PROPERTY *prop)$/;"	f
class_block	load.c	/^static int class_block(PARSER)$/;"	f	file:
class_count	class.c	/^static unsigned int class_count = 0;$/;"	v	file:
class_count	load_xml_handle.h	/^	int object_count, class_count;$/;"	m	class:gld_loadHndl
class_define_enumeration_member	class.c	/^int class_define_enumeration_member(CLASS *oclass, \/**< pointer to the class which implements the enumeration *\/$/;"	f
class_define_function	class.c	/^FUNCTION *class_define_function(CLASS *oclass, FUNCTIONNAME functionname, FUNCTIONADDR call)$/;"	f
class_define_map	class.c	/^int class_define_map(CLASS *oclass, \/**< the object class *\/$/;"	f
class_define_set_member	class.c	/^int class_define_set_member(CLASS *oclass, \/**< pointer to the class which implements the set *\/$/;"	f
class_define_type	class.c	/^int class_define_type(CLASS *oclass, DELEGATEDTYPE *delegation, ...)$/;"	f
class_explicit_declaration	load.c	/^static int class_explicit_declaration(PARSER, char *type, int size)$/;"	f	file:
class_explicit_definition	load.c	/^static int class_explicit_definition(PARSER, CLASS *oclass)$/;"	f	file:
class_export_function	load.c	/^static int class_export_function(PARSER, CLASS *oclass, char *fname, int fsize, char *arglist, int asize, char *code, int csize)$/;"	f	file:
class_external_function	load.c	/^static int class_external_function(PARSER, CLASS *oclass, CLASS **eclass,char *fname, int fsize)$/;"	f	file:
class_find_property	class.c	/^PROPERTY *class_find_property(CLASS *oclass,		\/**< the object class *\/$/;"	f
class_find_property_rec	class.c	/^PROPERTY *class_find_property_rec(CLASS *oclass, PROPERTYNAME name, CLASS *pclass)$/;"	f
class_get_class_from_classname	class.c	/^CLASS *class_get_class_from_classname(char *name) \/**< a pointer to a \\p NULL -terminated string containing the class name *\/$/;"	f
class_get_class_from_classname_in_module	class.c	/^CLASS *class_get_class_from_classname_in_module(char *name, MODULE *mod){$/;"	f
class_get_count	class.c	/^unsigned int class_get_count(void)$/;"	f
class_get_first_class	class.c	/^CLASS *class_get_first_class(void)$/;"	f
class_get_first_property	class.c	/^PROPERTY *class_get_first_property(CLASS *oclass) \/**< the object class *\/$/;"	f
class_get_function	class.c	/^FUNCTIONADDR class_get_function(char *classname, char *functionname)$/;"	f
class_get_last_class	class.c	/^CLASS *class_get_last_class(void)$/;"	f
class_get_next_property	class.c	/^PROPERTY *class_get_next_property(PROPERTY *prop)$/;"	f
class_get_property_typename	class.c	/^char *class_get_property_typename(PROPERTYTYPE type) \/**< the property type *\/$/;"	f
class_get_propertytype_from_typename	class.c	/^PROPERTYTYPE class_get_propertytype_from_typename(char *name) \/**< a string containing the name of the property type *\/$/;"	f
class_get_xsd	class.c	/^int class_get_xsd(CLASS *oclass, \/**< a pointer to the class to convert to XSD *\/$/;"	f
class_getname	object.h	/^	CLASS *(*class_getname)(char*);$/;"	m	struct:s_callbacks
class_intrinsic_function	load.c	/^static int class_intrinsic_function(PARSER, CLASS *oclass, int64 *functions, char *code, int size)$/;"	f	file:
class_intrinsic_function_name	load.c	/^static int class_intrinsic_function_name(PARSER, CLASS *oclass, int64 *function, char **ftype, char **fname)$/;"	f	file:
class_profiles	class.c	/^void class_profiles(void)$/;"	f
class_prop_in_class	class.c	/^PROPERTY *class_prop_in_class(CLASS *oclass, PROPERTY *prop)$/;"	f
class_properties	load.c	/^static int class_properties(PARSER, CLASS *oclass, int64 *functions, char *initcode, int initsize)$/;"	f	file:
class_property_to_string	class.c	/^int class_property_to_string(PROPERTY *prop, \/**< the property type *\/$/;"	f
class_register	class.c	/^CLASS *class_register(MODULE *module,			\/**< the module that implements the class *\/$/;"	f
class_register_type	class.c	/^DELEGATEDTYPE *class_register_type(CLASS *oclass, \/**< the object class *\/$/;"	f
class_saveall	class.c	/^int class_saveall(FILE *fp) \/**< a pointer to the stream FILE structure *\/$/;"	f
class_saveall_xml	class.c	/^int class_saveall_xml(FILE *fp) \/**< a pointer to the stream FILE structure *\/$/;"	f
class_string_to_property	class.c	/^int class_string_to_property(PROPERTY *prop, \/**< the type of the property at the \\p addr *\/$/;"	f
class_string_to_propertytype	class.c	/^int class_string_to_propertytype(PROPERTYTYPE type, void *addr, char *value)$/;"	f
clear	load_xml_handle.h	/^	void clear(){object_type[0] = 0; object_id[0] = 0; object_name[0] = 0; keyword[0] = 0;}$/;"	f	class:gldStack
clear	object.h	/^		void (*clear)(struct s_findlist*);$/;"	m	struct:s_callbacks::__anon34
clip	gridlabd.h	/^inline double clip(double x, \/**< the value to clip **\/$/;"	f
clock	object.h	/^	TIMESTAMP clock; \/**< object's private clock *\/$/;"	m	struct:s_object_list
clock_block	load.c	/^static int clock_block(PARSER)$/;"	f	file:
clock_properties	load.c	/^static int clock_properties(PARSER)$/;"	f	file:
clocks	class.h	/^		int64 clocks;$/;"	m	struct:s_class_list::__anon7
cmdMap	cmex.c	/^static CMDMAP cmdMap[] = $/;"	v	file:
cmdarg_load	cmdarg.c	/^STATUS cmdarg_load(int argc, \/**< the number of arguments in \\p argv *\/$/;"	f
cmdargs	module.h	/^	int (*cmdargs)(int,char**);$/;"	m	struct:s_module_list
cmex_create	cmex.c	/^void cmex_create(int nlhs, mxArray *plhs[], \/**< {properties} *\/$/;"	f
cmex_get	cmex.c	/^void cmex_get(int nlhs, mxArray *plhs[], \/**< {data} *\/$/;"	f
cmex_getenv	cmex.c	/^void cmex_getenv(int nlhs, mxArray *plhs[], \/**< () *\/$/;"	f
cmex_global	cmex.c	/^void cmex_global(int nlhs, mxArray *plhs[], \/**< () *\/$/;"	f
cmex_list	cmex.c	/^void cmex_list(int nlhs, mxArray *plhs[], \/**< entlist *\/$/;"	f
cmex_load	cmex.c	/^void cmex_load(int nlhs, mxArray *plhs[], \/**< () *\/$/;"	f
cmex_module	cmex.c	/^void cmex_module(int nlhs, mxArray *plhs[], \/**< () *\/$/;"	f
cmex_object_list	cmex.c	/^void cmex_object_list(int nlhs, mxArray *plhs[], \/**< entlist *\/$/;"	f
cmex_printerr	cmex.c	/^static int cmex_printerr(char *format, ...)$/;"	f	file:
cmex_set	cmex.c	/^void cmex_set(int nlhs, mxArray *plhs[], \/**< () *\/$/;"	f
cmex_setenv	cmex.c	/^void cmex_setenv(int nlhs, mxArray *plhs[], \/**< () *\/$/;"	f
cmex_start	cmex.c	/^void cmex_start(int nlhs, mxArray *plhs[], \/**< () *\/$/;"	f
cmex_version	cmex.c	/^void cmex_version(int nlhs, mxArray *plhs[], \/**< [major minor] *\/$/;"	f
code_block	load.c	/^char code_block[65536] = "";$/;"	v
code_used	load.c	/^int code_used = 0;$/;"	v
col	gui.c	/^static int table=-1, row[MAX_TABLES], col[MAX_TABLES], span[MAX_TABLES];$/;"	v	file:
comment	find.c	/^static int comment(PARSER)$/;"	f	file:
comment	load.c	/^static int comment(PARSER)$/;"	f	file:
comment_block	load.c	/^static int comment_block(PARSER)$/;"	f	file:
commit	class.h	/^	FUNCTIONADDR commit;$/;"	m	struct:s_class_list
commit_all	exec.c	/^static STATUS commit_all(TIMESTAMP t0){$/;"	f	file:
compare	cmdarg.c	/^int compare(const void *a, const void *b)$/;"	f
compare	find.c	/^static int compare(OBJECT *obj, FINDTYPE ftype, FINDOP op, void *value, char *propname)$/;"	f	file:
compare_double	find.c	/^static int compare_double(double a, FINDOP op, double b)$/;"	f	file:
compare_int	find.c	/^static int compare_int(int64 a, FINDOP op, int64 b)$/;"	f	file:
compare_int16	find.c	/^static int compare_int16(int16 a, FINDOP op, int64 b)$/;"	f	file:
compare_int32	find.c	/^static int compare_int32(int32 a, FINDOP op, int64 b)$/;"	f	file:
compare_int64	find.c	/^static int compare_int64(int64 a, FINDOP op, int64 b){$/;"	f	file:
compare_integer16_eq	find.c	/^int compare_integer16_eq(void *a, FINDVALUE b) { return *(int16*)a==(int16)b.integer;}$/;"	f
compare_integer16_ge	find.c	/^int compare_integer16_ge(void *a, FINDVALUE b) { return *(int16*)a>=(int16)b.integer;}$/;"	f
compare_integer16_gt	find.c	/^int compare_integer16_gt(void *a, FINDVALUE b) { return *(int16*)a>(int16)b.integer;}$/;"	f
compare_integer16_le	find.c	/^int compare_integer16_le(void *a, FINDVALUE b) { return *(int16*)a<=(int16)b.integer;}$/;"	f
compare_integer16_li	find.c	/^int compare_integer16_li(void *a, FINDVALUE b) {$/;"	f
compare_integer16_lt	find.c	/^int compare_integer16_lt(void *a, FINDVALUE b) { return *(int16*)a<(int16)b.integer;}$/;"	f
compare_integer16_ne	find.c	/^int compare_integer16_ne(void *a, FINDVALUE b) { return *(int16*)a!=(int16)b.integer;}$/;"	f
compare_integer16_nl	find.c	/^int compare_integer16_nl(void *a, FINDVALUE b) {$/;"	f
compare_integer32_eq	find.c	/^int compare_integer32_eq(void *a, FINDVALUE b) { return *(int32*)a==(int32)b.integer;}$/;"	f
compare_integer32_ge	find.c	/^int compare_integer32_ge(void *a, FINDVALUE b) { return *(int32*)a>=(int32)b.integer;}$/;"	f
compare_integer32_gt	find.c	/^int compare_integer32_gt(void *a, FINDVALUE b) { return *(int32*)a>(int32)b.integer;}$/;"	f
compare_integer32_le	find.c	/^int compare_integer32_le(void *a, FINDVALUE b) { return *(int32*)a<=(int32)b.integer;}$/;"	f
compare_integer32_li	find.c	/^int compare_integer32_li(void *a, FINDVALUE b) {$/;"	f
compare_integer32_lt	find.c	/^int compare_integer32_lt(void *a, FINDVALUE b) { return *(int32*)a<(int32)b.integer;}$/;"	f
compare_integer32_ne	find.c	/^int compare_integer32_ne(void *a, FINDVALUE b) { return *(int32*)a!=(int32)b.integer;}$/;"	f
compare_integer32_nl	find.c	/^int compare_integer32_nl(void *a, FINDVALUE b) {$/;"	f
compare_integer64_eq	find.c	/^int compare_integer64_eq(void *a, FINDVALUE b) { return *(int64*)a==(int64)b.integer;}$/;"	f
compare_integer64_ge	find.c	/^int compare_integer64_ge(void *a, FINDVALUE b) { return *(int64*)a>=(int64)b.integer;}$/;"	f
compare_integer64_gt	find.c	/^int compare_integer64_gt(void *a, FINDVALUE b) { return *(int64*)a>(int64)b.integer;}$/;"	f
compare_integer64_le	find.c	/^int compare_integer64_le(void *a, FINDVALUE b) { return *(int64*)a<=(int64)b.integer;}$/;"	f
compare_integer64_li	find.c	/^int compare_integer64_li(void *a, FINDVALUE b) {$/;"	f
compare_integer64_lt	find.c	/^int compare_integer64_lt(void *a, FINDVALUE b) { return *(int64*)a<(int64)b.integer;}$/;"	f
compare_integer64_ne	find.c	/^int compare_integer64_ne(void *a, FINDVALUE b) { return *(int64*)a!=(int64)b.integer;}$/;"	f
compare_integer64_nl	find.c	/^int compare_integer64_nl(void *a, FINDVALUE b) {$/;"	f
compare_integer_eq	find.c	/^int compare_integer_eq(void *a, FINDVALUE b) { return *(long*)a==(long)b.integer;}$/;"	f
compare_integer_ge	find.c	/^int compare_integer_ge(void *a, FINDVALUE b) { return *(long*)a>=(long)b.integer;}$/;"	f
compare_integer_gt	find.c	/^int compare_integer_gt(void *a, FINDVALUE b) { return *(long*)a>(long)b.integer;}$/;"	f
compare_integer_le	find.c	/^int compare_integer_le(void *a, FINDVALUE b) { return *(long*)a<=(long)b.integer;}$/;"	f
compare_integer_li	find.c	/^int compare_integer_li(void *a, FINDVALUE b) {$/;"	f
compare_integer_lt	find.c	/^int compare_integer_lt(void *a, FINDVALUE b) { return *(long*)a<(long)b.integer;}$/;"	f
compare_integer_ne	find.c	/^int compare_integer_ne(void *a, FINDVALUE b) { return *(long*)a!=(long)b.integer;}$/;"	f
compare_integer_nl	find.c	/^int compare_integer_nl(void *a, FINDVALUE b) {$/;"	f
compare_op	find.c	/^static int compare_op(PARSER, FINDOP *op)$/;"	f	file:
compare_pointer_eq	find.c	/^int compare_pointer_eq(void *a, FINDVALUE b) { return *(void**)a==b.pointer;}$/;"	f
compare_pointer_ge	find.c	/^int compare_pointer_ge(void *a, FINDVALUE b) { return *(void**)a>=b.pointer;}$/;"	f
compare_pointer_gt	find.c	/^int compare_pointer_gt(void *a, FINDVALUE b) { return *(void**)a>b.pointer;}$/;"	f
compare_pointer_le	find.c	/^int compare_pointer_le(void *a, FINDVALUE b) { return *(void**)a<=b.pointer;}$/;"	f
compare_pointer_li	find.c	/^int compare_pointer_li(void *a, FINDVALUE b) {return 0;}$/;"	f
compare_pointer_lt	find.c	/^int compare_pointer_lt(void *a, FINDVALUE b) { return *(void**)a<b.pointer;}$/;"	f
compare_pointer_ne	find.c	/^int compare_pointer_ne(void *a, FINDVALUE b) { return *(void**)a!=b.pointer;}$/;"	f
compare_pointer_nl	find.c	/^int compare_pointer_nl(void *a, FINDVALUE b) {return 1;}$/;"	f
compare_property	find.c	/^static int compare_property(OBJECT *obj, char *propname, FINDOP op, void *value)$/;"	f	file:
compare_property_alt	find.c	/^static int compare_property_alt(OBJECT *obj, char *propname, FINDOP op, void *value){$/;"	f	file:
compare_real_eq	find.c	/^int compare_real_eq(void *a, FINDVALUE b) { return *(double*)a==b.real;}$/;"	f
compare_real_ge	find.c	/^int compare_real_ge(void *a, FINDVALUE b) { return *(double*)a>=b.real;}$/;"	f
compare_real_gt	find.c	/^int compare_real_gt(void *a, FINDVALUE b) { return *(double*)a>b.real;}$/;"	f
compare_real_le	find.c	/^int compare_real_le(void *a, FINDVALUE b) { return *(double*)a<=b.real;}$/;"	f
compare_real_li	find.c	/^int compare_real_li(void *a, FINDVALUE b) {$/;"	f
compare_real_lt	find.c	/^int compare_real_lt(void *a, FINDVALUE b) { return *(double*)a<b.real;}$/;"	f
compare_real_ne	find.c	/^int compare_real_ne(void *a, FINDVALUE b) { return *(double*)a!=b.real;}$/;"	f
compare_real_nl	find.c	/^int compare_real_nl(void *a, FINDVALUE b) {$/;"	f
compare_string	find.c	/^static int compare_string(char *a, FINDOP op, char *b)$/;"	f	file:
compare_string_eq	find.c	/^int compare_string_eq(void *a, FINDVALUE b) {$/;"	f
compare_string_ge	find.c	/^int compare_string_ge(void *a, FINDVALUE b) { return *(char **)a != NULL && strcmp(*(char**)a,b.string)>=0;}$/;"	f
compare_string_gt	find.c	/^int compare_string_gt(void *a, FINDVALUE b) { return *(char **)a != NULL && strcmp(*(char**)a,b.string)>0;}$/;"	f
compare_string_le	find.c	/^int compare_string_le(void *a, FINDVALUE b) { return *(char **)a != NULL && strcmp(*(char**)a,b.string)<=0;}$/;"	f
compare_string_li	find.c	/^int compare_string_li(void *a, FINDVALUE b) {return match(*(char **)a, b.string);}$/;"	f
compare_string_lt	find.c	/^int compare_string_lt(void *a, FINDVALUE b) { return *(char **)a != NULL && strcmp(*(char**)a,b.string)<0;}$/;"	f
compare_string_ne	find.c	/^int compare_string_ne(void *a, FINDVALUE b) { return *(char **)a != NULL && strcmp(*(char**)a,b.string)!=0;}$/;"	f
compare_string_nl	find.c	/^int compare_string_nl(void *a, FINDVALUE b) {$/;"	f
comparemap	find.c	/^} comparemap[] = \/** @todo add other integer sizes  (ticket #23) *\/$/;"	v	typeref:struct:__anon53
comparemap_ext	find.c	/^} comparemap_ext[] =$/;"	v	typeref:struct:__anon54
compile_code	load.c	/^static STATUS compile_code(CLASS *oclass, int64 functions)$/;"	f	file:
compile_string_list	object.c	/^STRING_LIST *compile_string_list(OBJECTTREE *tree, STRING_LIST *list){$/;"	f
complex	complex.h	/^	inline complex() \/**< create a zero complex number *\/$/;"	f	class:complex
complex	complex.h	/^	inline complex(double re) \/**< create a complex number with only a real part *\/$/;"	f	class:complex
complex	complex.h	/^	inline complex(double re, double im, CNOTATION nf=CNOTATION_DEFAULT) \/**< create a complex number with both real and imaginary parts *\/$/;"	f	class:complex
complex	complex.h	/^class complex { $/;"	c
complex	complex.h	/^} complex; $/;"	t	typeref:struct:__anon13
complex_set_polar	complex.h	325;"	d
complex_set_power_factor	complex.h	326;"	d
complex_unit	load.c	/^static int complex_unit(PARSER,complex *pValue,UNIT **unit)$/;"	f	file:
complex_value	load.c	/^static int complex_value(PARSER, complex *pValue)$/;"	f	file:
complex_var	object.h	/^		complex *(*complex_var)(OBJECT *obj, PROPERTY *prop);$/;"	m	struct:s_callbacks::s_objvar_struct
complex_var	object.h	/^		complex *(*complex_var)(OBJECT *obj, char *name);$/;"	m	struct:s_callbacks::s_objvar_name_struct
compute_dstevent	timestamp.c	/^TIMESTAMP compute_dstevent(int year, SPEC *spec, time_t offset){$/;"	f
config	enduse.h	/^	set config;					\/* end-use configuration *\/$/;"	m	struct:s_enduse
constflags	find.h	/^	PGMCONSTFLAGS constflags; \/* bits to indicate which criteria result in constant sets *\/$/;"	m	struct:s_findpgm
convert	object.h	/^	} convert;$/;"	m	struct:s_callbacks	typeref:struct:s_callbacks::__anon40
convert_from_enduse	enduse.c	/^int convert_from_enduse(char *string,int size,void *data, PROPERTY *prop)$/;"	f
convert_from_float	class.c	/^int convert_from_float(char *a, int b, void *c, PROPERTY *d){return 0;}$/;"	f
convert_from_latitude	object.c	/^int convert_from_latitude(double v, void *buffer, int bufsize){$/;"	f
convert_from_loadshape	loadshape.c	/^int convert_from_loadshape(char *string,int size,void *data, PROPERTY *prop)$/;"	f
convert_from_longitude	object.c	/^int convert_from_longitude(double v, void *buffer, int bufsize){$/;"	f
convert_from_real	class.c	/^int convert_from_real(char *a, int b, void *c, PROPERTY *d){return 0;}$/;"	f
convert_from_timestamp	object.h	/^		int (*convert_from_timestamp)(TIMESTAMP ts, char *buffer, int size);$/;"	m	struct:s_callbacks::__anon36
convert_from_timestamp	timestamp.c	/^int convert_from_timestamp(TIMESTAMP ts, char *buffer, int size)$/;"	f
convert_to_enduse	enduse.c	/^int convert_to_enduse(char *string, void *data, PROPERTY *prop)$/;"	f
convert_to_float	class.c	/^int convert_to_float(char *a, void *b, PROPERTY *c){return 0;}$/;"	f
convert_to_latitude	object.c	/^double convert_to_latitude(char *buffer){$/;"	f
convert_to_loadshape	loadshape.c	/^int convert_to_loadshape(char *string, void *data, PROPERTY *prop)$/;"	f
convert_to_longitude	object.c	/^double convert_to_longitude(char *buffer){$/;"	f
convert_to_real	class.c	/^int convert_to_real(char *a, void *b, PROPERTY *c){return 0;}$/;"	f
convert_to_timestamp	object.h	/^		TIMESTAMP (*convert_to_timestamp)(char *value);$/;"	m	struct:s_callbacks::__anon36
convert_to_timestamp	timestamp.c	/^TIMESTAMP convert_to_timestamp(char *value)$/;"	f
copy	object.h	/^		struct s_findlist *(*copy)(struct s_findlist *);$/;"	m	struct:s_callbacks::__anon34	typeref:struct:s_callbacks::__anon34::copy
count	class.h	/^		int32 count;$/;"	m	struct:s_class_list::__anon7
count	exec.h	/^	int count; \/**< the thread count *\/$/;"	m	struct:thread_data
count	schedule.h	/^	unsigned int count[MAXBLOCKS];		\/**< the number of values given in each block *\/$/;"	m	struct:s_schedule
create	class.c	/^	int (*create)(void*); \/**< the function used to create the property, if any *\/$/;"	m	struct:s_property_specs	file:
create	class.h	/^	FUNCTIONADDR create;$/;"	m	struct:s_class_list
create	object.h	/^		GLOBALVAR *(*create)(char *name, ...);$/;"	m	struct:s_callbacks::__anon38
create	object.h	/^		SCHEDULE *(*create)(char *name, char *definition);$/;"	m	struct:s_callbacks::__anon41
create	object.h	/^		int (*create)(struct s_enduse *e);$/;"	m	struct:s_callbacks::__anon43
create	object.h	/^		int (*create)(struct s_loadshape *s);$/;"	m	struct:s_callbacks::__anon42
create	object.h	/^	} create;$/;"	m	struct:s_callbacks	typeref:struct:s_callbacks::__anon31
create_aggregate	object.h	/^	struct s_aggregate *(*create_aggregate)(char *aggregator, char *group_expression);$/;"	m	struct:s_callbacks	typeref:struct:s_callbacks::create_aggregate
create_exception_handler	exception.c	/^EXCEPTIONHANDLER *create_exception_handler(void)$/;"	f
create_exception_handler	object.h	/^		EXCEPTIONHANDLER *(*create_exception_handler)();$/;"	m	struct:s_callbacks::__anon37
create_item	list.c	/^static LISTITEM *create_item(void *data,	\/* a pointer to the data *\/$/;"	f	file:
create_object	test_framework.h	/^	template <class T> static T *create_object(const char *classname)$/;"	f	class:test_helper
create_thread	threadpool.c	/^static __inline int create_thread(void * (*proc)(void *), void *arg)$/;"	f	file:
create_thread	threadpool.c	143;"	d	file:
create_thread	threadpool.c	78;"	d	file:
critsec	threadpool.c	/^	CRITICAL_SECTION critsec;$/;"	m	struct:__anon58	file:
curr_stream	output.c	/^static FILE *curr_stream[3] = {NULL, NULL, NULL};$/;"	v	file:
current	enduse.h	/^	complex current;			\/* constant current portion of load in kW *\/$/;"	m	struct:s_enduse
current_fraction	enduse.h	/^	double current_fraction;	\/* constant current fraction (pu load) *\/$/;"	m	struct:s_enduse
current_module	load.c	/^static MODULE *current_module = NULL; \/* context module *\/$/;"	v	file:
current_namespace	object.c	/^NAMESPACE *current_namespace = NULL;$/;"	v
current_object	load.c	/^static OBJECT *current_object = NULL; \/* context object *\/$/;"	v	file:
current_tzname	timestamp.c	/^static char current_tzname[64], tzstd[32], tzdst[32];$/;"	v	file:
d	loadshape.h	/^	double d[2];		\/**< the state transition thresholds *\/$/;"	m	struct:s_loadshape
dPdV	loadshape.h	/^	double dPdV;		\/**< the voltage sensitivity of the load *\/$/;"	m	struct:s_loadshape
dashed_name	load.c	/^static int dashed_name(PARSER, char *result, int size)$/;"	f	file:
data	class.h	/^	char *data; \/**< the data that is delegated *\/$/;"	m	struct:s_delegatedvalue
data	cmex.h	/^	double *data;$/;"	m	struct:__anon8
data	debug.c	/^		int64 data; \/**< type-neutral criteria *\/ $/;"	m	union:s_breakpoint::__anon52	file:
data	exec.h	/^	struct sync_data *data; \/**< pointer to the sync state structure *\/$/;"	m	struct:thread_data	typeref:struct:thread_data::sync_data
data	gui.h	/^	void *data;$/;"	m	struct:s_guientity
data	list.h	/^	void *data;$/;"	m	struct:s_listitem
data	schedule.h	/^	double data[MAXBLOCKS*MAXVALUES];	\/**< the list of values used in each block *\/$/;"	m	struct:s_schedule
data_to_string	class.c	/^	int (*data_to_string)(char *,int,void*,PROPERTY*); \/**< the function to convert from data to a string *\/$/;"	m	struct:s_property_specs	file:
day	timestamp.c	/^	int month, nth, day, hour, minute;$/;"	m	struct:__anon60	file:
day	timestamp.h	/^	unsigned short day; \/**< day (1 to 28\/29\/30\/31) *\/$/;"	m	struct:s_datetime
daysinmonth	timestamp.c	/^static daysinmonth[] = {31,28,31,30,31,30,31,31,30,31,30,31};$/;"	v	file:
de	loadshape.h	/^	double de[2];		\/**< the state transition threshold stdevs (not used yet) *\/$/;"	m	struct:s_loadshape
debug	output.c	/^	FILE *debug;$/;"	m	struct:s_redirection	file:
debug_active	debug.c	/^static int debug_active = 1; \/**< flag indicating that the debugger is currently active *\/$/;"	v	file:
debug_notify_error	debug.c	/^void debug_notify_error(void)$/;"	f
debug_traverse_tree	object.c	/^void debug_traverse_tree(OBJECTTREE *tree){$/;"	f
debugger	load.c	/^static STATUS debugger(char *target)$/;"	f	file:
default_printerr	output.c	/^static int default_printerr(char *format,...)$/;"	f	file:
default_printstd	output.c	/^static int default_printstd(char *format,...)$/;"	f	file:
define	object.h	/^		FUNCTION *(*define)(CLASS*,FUNCTIONNAME,FUNCTIONADDR);$/;"	m	struct:s_callbacks::__anon32
define_enumeration_member	object.h	/^	int (*define_enumeration_member)(CLASS*,char*,char*,enumeration);$/;"	m	struct:s_callbacks
define_map	object.h	/^	int (*define_map)(CLASS*,...);$/;"	m	struct:s_callbacks
define_set_member	object.h	/^	int (*define_set_member)(CLASS*,char*,char*,unsigned int64);$/;"	m	struct:s_callbacks
define_type	object.h	/^	int (*define_type)(CLASS*,DELEGATEDTYPE*,...);$/;"	m	struct:s_callbacks
definition	schedule.h	/^	char definition[65536];				\/**< the definition string of the schedule *\/$/;"	m	struct:s_schedule
del	object.h	/^		void (*del)(struct s_findlist*, OBJECT*);$/;"	m	struct:s_callbacks::__anon34
delegated	class.h	/^typedef DELEGATEDVALUE* delegated; \/* delegated data type *\/$/;"	t
delegation	class.h	/^	DELEGATEDTYPE *delegation; \/**< property delegation, if any; \\p NULL if none *\/$/;"	m	struct:s_property_map
delete_exception_handler	exception.c	/^void delete_exception_handler(EXCEPTIONHANDLER *ptr) \/**< a pointer to the exception handler *\/$/;"	f
delete_exception_handler	object.h	/^		void (*delete_exception_handler)(EXCEPTIONHANDLER *ptr);$/;"	m	struct:s_callbacks::__anon37
delete_pidfile	main.c	/^void delete_pidfile(void)$/;"	f
deleted_object_count	object.c	/^static OBJECTNUM deleted_object_count = 0;$/;"	v	file:
delim	find.c	1278;"	d	file:
delim_value	load.c	/^static int delim_value(PARSER, char *result, int size, char *delims)$/;"	f	file:
demand	enduse.h	/^	complex demand;				\/* maximum power in kW (can be reset) *\/$/;"	m	struct:s_enduse
depends	object.h	/^	int (*depends)(char *name, unsigned char major, unsigned char minor, unsigned short build);$/;"	m	struct:s_callbacks
depth	load_xml_handle.h	/^	int depth;$/;"	m	class:gld_loadHndl
description	class.h	/^	char *description; \/**< description of property *\/$/;"	m	struct:s_property_map
destroy_item	list.c	/^static void destroy_item(LISTITEM *item) \/**< a pointer to the LISTITEM structure of the item *\/$/;"	f	file:
detail	cmex.c	/^	char *detail;$/;"	m	struct:__anon49	file:
df_keys	globals.c	/^static KEYWORD df_keys[] = {$/;"	v	file:
did_load	load_xml_handle.h	/^	bool did_load(){return load_state;}$/;"	f	class:gld_loadHndl
dlload_error	module.c	/^void dlload_error(const char *filename)$/;"	f
do_sync_all	test.c	/^STATUS do_sync_all(PASSCONFIG pass)$/;"	f
done_cond	threadpool.c	/^	pthread_cond_t exec_cond, done_cond;$/;"	m	struct:__anon59	file:
done_event	threadpool.c	/^	HANDLE exec_sem, done_event;$/;"	m	struct:__anon58	file:
dotted_name	load.c	/^static int dotted_name(PARSER, char *result, int size)$/;"	f	file:
double_var	object.h	/^		double *(*double_var)(OBJECT *obj, PROPERTY *prop);$/;"	m	struct:s_callbacks::s_objvar_struct
double_var	object.h	/^		double *(*double_var)(OBJECT *obj, char *name);$/;"	m	struct:s_callbacks::s_objvar_name_struct
dow	timestamp.c	/^static char *dow[] = {"Sun","Mon","Tue","Wed","Thu","Fri","Sat"};$/;"	v	file:
dstend	timestamp.c	/^static TIMESTAMP dststart[1000], dstend[1000];$/;"	v	file:
dststart	timestamp.c	/^static TIMESTAMP dststart[1000], dstend[1000];$/;"	v	file:
dt	loadshape.h	/^			unsigned int dt;			\/**< the time resolution of the schedule (default is 3600s) *\/$/;"	m	struct:s_loadshape::__anon24::__anon29
dtnext	object.h	/^		long (*dtnext)(SCHEDULE *sch, SCHEDULEINDEX index);$/;"	m	struct:s_callbacks::__anon41
dtnext	schedule.h	/^	unsigned char dtnext[14][366*24*60];\/**< the time until the next schedule change (in minutes) *\/$/;"	m	struct:s_schedule
duration	loadshape.c	288;"	d	file:
duration	loadshape.c	304;"	d	file:
duration	schedule.h	/^	double duration;					\/**< the duration of the current scheduled value (in hours) *\/$/;"	m	struct:s_schedule
e	unit.c	/^static double e = 1.602189246e-19;	\/**< C *\/$/;"	v	file:
e	unit.h	/^	double c,e,h,k,m,s,a,b; \/**< the unit parameters *\/$/;"	m	struct:s_unit
enabled	debug.c	/^	int enabled; \/**< flag where the breakpoint is enabled *\/$/;"	m	struct:s_breakpoint	file:
enabled	debug.c	/^	int enabled; \/**< flag whether the watchpoint is enabled *\/$/;"	m	struct:s_watchpoint	file:
end	exec.c	/^clock_t start, end;$/;"	v
end_obj	enduse.h	/^	struct s_object_list *end_obj;$/;"	m	struct:s_enduse	typeref:struct:s_enduse::s_object_list
endspan	gui.c	/^static void endspan()$/;"	f	file:
endtable	gui.c	/^static void endtable()$/;"	f	file:
enduse	enduse.h	/^} enduse;$/;"	t	typeref:struct:s_enduse
enduse	object.h	/^	} enduse;$/;"	m	struct:s_callbacks	typeref:struct:s_callbacks::__anon43
enduse_create	enduse.c	/^int enduse_create(enduse *data)$/;"	f
enduse_init	enduse.c	/^int enduse_init(enduse *e)$/;"	f
enduse_initall	enduse.c	/^int enduse_initall(void)$/;"	f
enduse_list	enduse.c	/^static enduse *enduse_list = NULL;$/;"	v	file:
enduse_magic	enduse.c	/^static unsigned int enduse_magic = 0x8c3d7762;$/;"	v	file:
enduse_publish	enduse.c	/^int enduse_publish(CLASS *oclass, PROPERTYADDR struct_address, char *prefix)$/;"	f
enduse_sync	enduse.c	/^TIMESTAMP enduse_sync(enduse *e, PASSCONFIG pass, TIMESTAMP t1)$/;"	f
enduse_syncall	enduse.c	/^TIMESTAMP enduse_syncall(TIMESTAMP t1)$/;"	f
enduse_test	enduse.c	/^int enduse_test(void)$/;"	f
energy	enduse.h	/^	complex energy;				\/* total energy in kWh *\/$/;"	m	struct:s_enduse
energy	loadshape.h	/^			double energy;		\/**< the total energy used over the shape (0 if power is used) *\/$/;"	m	struct:s_loadshape::__anon24::__anon25
energy	loadshape.h	/^			double energy;		\/**< the total energy used over the shape *\/$/;"	m	struct:s_loadshape::__anon24::__anon26
energy	loadshape.h	/^			double energy;		\/**< the total energy used over the shape *\/$/;"	m	struct:s_loadshape::__anon24::__anon27
energy	loadshape.h	/^			double energy;		\/**< the total energy used over the shape *\/$/;"	m	struct:s_loadshape::__anon24::__anon28
enter_critical_section	threadpool.c	132;"	d	file:
enter_critical_section	threadpool.c	147;"	d	file:
enter_critical_section	threadpool.c	79;"	d	file:
enum_var	object.h	/^		enumeration *(*enum_var)(OBJECT *obj, PROPERTY *prop);$/;"	m	struct:s_callbacks::s_objvar_struct
enum_var	object.h	/^		enumeration *(*enum_var)(OBJECT *obj, char *name);$/;"	m	struct:s_callbacks::s_objvar_name_struct
enumeration	class.h	/^typedef int enumeration; \/* enumerations (any one of a list of values) *\/$/;"	t
env	gui.h	/^	char *env;$/;"	m	struct:s_guientity
environment_start	environment.c	/^STATUS environment_start(int argc, \/**< the number of arguments to pass to the environment *\/$/;"	f
errmsg	load_xml_handle.h	/^	char	errmsg[1024];$/;"	m	class:gld_loadHndl
error	output.c	/^	FILE *error;$/;"	m	struct:s_redirection	file:
error_caught	debug.c	/^static int error_caught = 0; \/**< flag indicating that the debugger has seen an error *\/$/;"	v	file:
eventlist	realtime.c	/^static EVENT *eventlist = NULL;$/;"	v	file:
exception	object.h	/^	} exception;$/;"	m	struct:s_callbacks	typeref:struct:s_callbacks::__anon37
exception_msg	exception.c	/^char *exception_msg(void)$/;"	f
exception_msg	object.h	/^		char *(*exception_msg)(void);$/;"	m	struct:s_callbacks::__anon37
exec	debug.c	/^static STATUS exec(char *format,...)$/;"	f	file:
exec	load.c	/^static STATUS exec(char *format,...)$/;"	f	file:
exec_add_breakpoint	debug.c	/^static int exec_add_breakpoint(BREAKPOINTTYPE type, \/**< the breakpoint type *\/$/;"	f	file:
exec_add_watchpoint	debug.c	/^static int exec_add_watchpoint(OBJECT *obj, \/**< the object being watched *\/$/;"	f	file:
exec_cond	threadpool.c	/^	pthread_cond_t exec_cond, done_cond;$/;"	m	struct:__anon59	file:
exec_debug	debug.c	/^int exec_debug(struct sync_data *data, \/**< the current sync status of the mail loop *\/$/;"	f
exec_debug_cmd	debug.c	/^DEBUGCMD exec_debug_cmd(struct sync_data *data, \/**< the current sync status of the mail loop *\/$/;"	f
exec_getranks	exec.c	/^INDEX **exec_getranks(void)$/;"	f
exec_init	exec.c	/^int exec_init()$/;"	f
exec_loop	threadpool.c	/^static __inline void exec_loop(struct threadpool *tp, int thread)$/;"	f	file:
exec_sem	threadpool.c	/^	HANDLE exec_sem, done_event;$/;"	m	struct:__anon58	file:
exec_sighandler	debug.c	/^void exec_sighandler(int sig) \/**< the signal number, see \\p <signal.h> *\/ $/;"	f
exec_start	exec.c	/^STATUS exec_start(void)$/;"	f
exec_test	exec.c	/^STATUS exec_test(struct sync_data *data, \/**< the synchronization state data *\/$/;"	f
expanded_value	load.c	/^static int expanded_value(char *text, char *result, int size, char *delims)$/;"	f	file:
exponential	object.h	/^		double (*exponential)(double l);$/;"	m	struct:s_callbacks::__anon35
export_file	module.h	/^	int (*export_file)(char *file);$/;"	m	struct:s_module_list
expression	find.c	/^static int expression(PARSER, FINDPGM **pgm)$/;"	f	file:
expression	load.c	/^static int expression(PARSER, double *pValue, UNIT **unit, OBJECT *obj){$/;"	f	file:
expression_list	find.c	/^static int expression_list(PARSER, FINDPGM **pgm)$/;"	f	file:
f	complex.h	/^	CNOTATION f; \/**< the default notation to use *\/$/;"	m	class:complex
f	complex.h	/^	CNOTATION f; \/**< the default notation used *\/$/;"	m	struct:__anon13
fExpandNS	load_xml_handle.h	/^	bool			fExpandNS ;$/;"	m	class:gld_loadHndl
fFormatter	load_xml_handle.h	/^    XMLFormatter    fFormatter;$/;"	m	class:gld_loadHndl
false	class.h	48;"	d
fast_enter_critical_section	threadpool.c	/^static __inline void fast_enter_critical_section(struct threadpool *tp)$/;"	f	file:
fast_enter_critical_section	threadpool.c	146;"	d	file:
file	load.c	/^	char file[256];$/;"	m	struct:s_include_list	file:
file	load.h	/^	char *file;$/;"	m	struct:s_unresolved
file	object.h	/^	} file;$/;"	m	struct:s_callbacks	typeref:struct:s_callbacks::__anon39
filelength	server.c	/^static int filelength(int fd)$/;"	f	file:
filename	load.c	/^static char filename[1024];$/;"	v	file:
filename_parts	load.c	/^static void filename_parts(char *fullname, char *path, char *name, char *ext)$/;"	f	file:
filepath	unit.c	/^static char filepath[1024] = "unitfile.txt";$/;"	v	file:
find	object.h	/^		GLOBALVAR *(*find)(char *name);$/;"	m	struct:s_callbacks::__anon38
find	object.h	/^		SCHEDULE *(*find)(char *name);$/;"	m	struct:s_callbacks::__anon41
find	object.h	/^	} find;$/;"	m	struct:s_callbacks	typeref:struct:s_callbacks::__anon34
find_class	cmex.c	/^static CLASS *find_class(mxArray *handle)$/;"	f	file:
find_file	find.c	/^char *find_file(char *name, \/**< the name of the file to find *\/$/;"	f
find_file	object.h	/^		char *(*find_file)(char *name, char *path, int mode);$/;"	m	struct:s_callbacks::__anon39
find_first	find.c	/^OBJECT *find_first(FINDLIST *list) \/**< the search list to scan *\/$/;"	f
find_global	cmex.c	/^static GLOBALVAR *find_global(mxArray *handle)$/;"	f	file:
find_makearray	find.c	/^int find_makearray(FINDLIST *list, \/**< the search list to scan *\/$/;"	f
find_mkpgm	find.c	/^FINDPGM *find_mkpgm(char *search)$/;"	f
find_module	cmex.c	/^static MODULE *find_module(mxArray *handle)$/;"	f	file:
find_next	find.c	/^OBJECT *find_next(FINDLIST *list, \/**< the search list to scan *\/$/;"	f
find_object	cmex.c	/^static OBJECT *find_object(mxArray *handle)$/;"	f	file:
find_objects	find.c	/^FINDLIST *find_objects(FINDLIST *start, ...)$/;"	f
find_pgmconstants	find.c	/^PGMCONSTFLAGS find_pgmconstants(FINDPGM *pgm)$/;"	f
find_property	object.h	/^	PROPERTY *(*find_property)(CLASS *, PROPERTYNAME);$/;"	m	struct:s_callbacks
find_runpgm	find.c	/^FINDLIST *find_runpgm(FINDLIST *list, FINDPGM *pgm)$/;"	f
find_value_index	schedule.c	/^int find_value_index (SCHEDULE *sch, \/\/\/ schedule to search$/;"	f
findin_tree	object.c	/^static OBJECTTREE **findin_tree(OBJECTTREE *tree, OBJECTNAME name){$/;"	f	file:
findlist_add	find.c	/^void findlist_add(FINDLIST *list, OBJECT *obj)$/;"	f
findlist_clear	find.c	/^void findlist_clear(FINDLIST *list)$/;"	f
findlist_copy	find.c	/^FINDLIST *findlist_copy(FINDLIST *list)$/;"	f
findlist_del	find.c	/^void findlist_del(FINDLIST *list, OBJECT *obj)$/;"	f
findlist_nop	find.c	/^static void findlist_nop(FINDLIST *list, OBJECT *obj)$/;"	f	file:
finite	random.c	32;"	d	file:
first	list.h	/^	LISTITEM *first;$/;"	m	struct:s_list
first	load_xml_handle.h	/^	int first, last;$/;"	m	class:gld_loadHndl
first_breakpoint	debug.c	/^static BREAKPOINT *first_breakpoint=NULL, \/**< pointer to the first breakpoint *\/$/;"	v	file:
first_class	class.c	/^static CLASS *first_class = NULL; \/**< first class in class list *\/$/;"	v	file:
first_module	module.c	/^MODULE *first_module = NULL;$/;"	v
first_object	object.c	/^static OBJECT *first_object = NULL;$/;"	v	file:
first_ordinal	index.h	/^	int first_ordinal;	\/**< the first ordinal in the list *\/$/;"	m	struct:s_index
first_unresolved	load.c	/^static UNRESOLVED *first_unresolved = NULL;$/;"	v	file:
first_used	index.h	/^	int first_used;		\/**< the first ordinal in use *\/$/;"	m	struct:s_index
first_watchpoint	debug.c	/^static WATCHPOINT *first_watchpoint=NULL, \/**< a pointer to the first watchpoint *\/$/;"	v	file:
flags	aggregate.h	/^	unsigned char flags; \/**< aggregation flags (e.g., AF_ABS) *\/$/;"	m	struct:s_aggregate
flags	class.h	/^	PROPERTYFLAGS flags; \/**< property flags (e.g., PF_RECALC) *\/$/;"	m	struct:s_property_map
flags	globals.h	/^	unsigned long flags;$/;"	m	struct:s_globalvar
flags	load.h	/^	int flags;$/;"	m	struct:s_unresolved
flags	object.h	/^	unsigned long flags; \/**< object flags *\/$/;"	m	struct:s_object_list
flags	schedule.h	/^	int flags;							\/**< the schedule flags (see SN_*) *\/$/;"	m	struct:s_schedule
fmap	class.h	/^	FUNCTION *fmap;$/;"	m	struct:s_class_list
foreign	object.h	/^		OBJECT *(*foreign)(OBJECT *);$/;"	m	struct:s_callbacks::__anon31
format_object	load.c	/^static char *format_object(OBJECT *obj)$/;"	f	file:
forward_slashes	load.c	/^static char *forward_slashes(char *a)$/;"	f	file:
fp	gui.c	/^void *fp = NULL;$/;"	v
fptr	load.c	/^	double (*fptr)(double);$/;"	m	struct:s_rpn_func	file:
fraction	schedule.h	/^	double fraction;					\/**< the fractional weight of the block of the current value (pu time) *\/$/;"	m	struct:s_schedule
free	object.h	/^	void (*free)(void*);$/;"	m	struct:s_callbacks
free_index	load.c	/^static void free_index(void)$/;"	f	file:
from_string	class.h	/^	int (*from_string)(void *addr, char *value); \/**< the function that converts from a string to the data *\/$/;"	m	struct:s_delegatedtype
funcstr	load.h	/^	char1024 funcstr;$/;"	m	struct:s_unresolved_func
function	object.h	/^	} function;$/;"	m	struct:s_callbacks	typeref:struct:s_callbacks::__anon32
functional	load.c	/^static int functional(PARSER, double *pValue)$/;"	f	file:
functional_unit	load.c	/^static int functional_unit(PARSER,double *pValue,UNIT **unit)$/;"	f	file:
gamma	object.h	/^		double (*gamma)(double a, double b);$/;"	m	struct:s_callbacks::__anon35
get	object.h	/^		FUNCTIONADDR (*get)(char*,char*);$/;"	m	struct:s_callbacks::__anon32
get_addr	object.h	/^		void *(*get_addr)(OBJECT *, char *);$/;"	m	struct:s_callbacks::__anon33
get_class_by_name	test_callbacks.h	/^	CLASS* (*get_class_by_name)(char* name);$/;"	m	struct:s_test_callbacks
get_class_by_name	test_framework.h	/^	static CLASS* get_class_by_name(char *name){$/;"	f	class:test_helper
get_exe_path	module.c	/^int get_exe_path(char *buf, int len, void *mod){	\/* void for GetModuleFileName, a windows func *\/$/;"	f
get_global_clock	test.c	/^TIMESTAMP get_global_clock(void)$/;"	f
get_global_clock	test_callbacks.h	/^	TIMESTAMP (*get_global_clock)(void);$/;"	m	struct:s_test_callbacks
get_global_clock	test_framework.h	/^	static TIMESTAMP get_global_clock(){$/;"	f	class:test_helper
get_global_clock_string	globals.c	/^char * get_global_clock_string()$/;"	f
get_global_run_realtime	globals.c	/^int get_global_run_realtime()$/;"	f
get_module_types	object.c	/^STRING_LIST *get_module_types(){$/;"	f
get_module_var	object.h	/^	void *(*get_module_var)(MODULE *module, char *varname);$/;"	m	struct:s_callbacks
get_next_unlinked	load.c	/^static OBJECT *get_next_unlinked(CLASS *oclass)$/;"	f	file:
get_object	object.h	/^	OBJECT *(*get_object)(char *name);$/;"	m	struct:s_callbacks
get_object_data	cmex.c	/^static mxArray *get_object_data(OBJECT *obj)$/;"	f	file:
get_objname	debug.c	/^static char *get_objname(OBJECT *obj)$/;"	f	file:
get_oflags	object.h	/^	int (*get_oflags)(KEYWORD **extflags);$/;"	m	struct:s_callbacks
get_property	object.h	/^		PROPERTY *(*get_property)(OBJECT*,PROPERTYNAME);$/;"	m	struct:s_callbacks::__anon33
get_property_at_addr	object.c	/^static PROPERTY *get_property_at_addr(OBJECT *obj, void *addr)$/;"	f	file:
get_reference	object.h	/^		OBJECT *(*get_reference)(OBJECT *, char*);$/;"	m	struct:s_callbacks::__anon33
get_unit	object.h	/^		char *(*get_unit)(OBJECT *, char *);$/;"	m	struct:s_callbacks::__anon33
get_value_by_addr	object.h	/^		int (*get_value_by_addr)(OBJECT *, void*, char*, int size,PROPERTY*);$/;"	m	struct:s_callbacks::__anon33
get_value_by_name	object.h	/^		int (*get_value_by_name)(OBJECT *, char*, char*, int size);$/;"	m	struct:s_callbacks::__anon33
getpid	load.c	399;"	d	file:
getpid	main.c	101;"	d	file:
getpid	platform.h	27;"	d
getvar	module.h	/^	void* (*getvar)(char *varname,char *value,unsigned int size);$/;"	m	struct:s_module_list
getvar	object.h	/^		char *(*getvar)(char *name, char *buffer, int size);$/;"	m	struct:s_callbacks::__anon38
gl_convert	gridlabd.h	609;"	d
gl_convert_ex	gridlabd.h	614;"	d
gl_create_aggregate	gridlabd.h	695;"	d
gl_create_array	gridlabd.h	386;"	d
gl_create_foreign	gridlabd.h	391;"	d
gl_create_object	gridlabd.h	381;"	d
gl_debug	gridlabd.h	274;"	d
gl_debug	gridlabd.h	276;"	d
gl_enduse_create	gridlabd.h	/^inline int gl_enduse_create(enduse *e)$/;"	f
gl_enduse_sync	gridlabd.h	/^inline TIMESTAMP gl_enduse_sync(enduse *e, TIMESTAMP t1)$/;"	f
gl_error	gridlabd.h	268;"	d
gl_find_module	gridlabd.h	328;"	d
gl_find_next	gridlabd.h	678;"	d
gl_find_objects	gridlabd.h	673;"	d
gl_find_property	gridlabd.h	330;"	d
gl_find_unit	gridlabd.h	616;"	d
gl_findfile	gridlabd.h	326;"	d
gl_findlist_add	gridlabd.h	684;"	d
gl_findlist_clear	gridlabd.h	686;"	d
gl_findlist_copy	gridlabd.h	683;"	d
gl_findlist_del	gridlabd.h	685;"	d
gl_free	gridlabd.h	690;"	d
gl_get_addr	gridlabd.h	657;"	d
gl_get_complex	gridlabd.h	629;"	d
gl_get_complex_by_name	gridlabd.h	631;"	d
gl_get_double	gridlabd.h	651;"	d
gl_get_double_by_name	gridlabd.h	649;"	d
gl_get_enum	gridlabd.h	633;"	d
gl_get_enum_by_name	gridlabd.h	635;"	d
gl_get_function	gridlabd.h	/^inline FUNCTIONADDR gl_get_function(OBJECT *obj, char *name)$/;"	f
gl_get_function	gridlabd.h	427;"	d
gl_get_int16	gridlabd.h	637;"	d
gl_get_int16_by_name	gridlabd.h	639;"	d
gl_get_int32	gridlabd.h	643;"	d
gl_get_int32_by_name	gridlabd.h	641;"	d
gl_get_int64	gridlabd.h	647;"	d
gl_get_int64_by_name	gridlabd.h	645;"	d
gl_get_loadshape_value	gridlabd.h	/^inline double gl_get_loadshape_value(loadshape *shape)$/;"	f
gl_get_module_var	gridlabd.h	321;"	d
gl_get_object	gridlabd.h	618;"	d
gl_get_object_count	gridlabd.h	622;"	d
gl_get_object_prop	gridlabd.h	624;"	d
gl_get_oflags	gridlabd.h	864;"	d
gl_get_property	gridlabd.h	/^inline PROPERTY *gl_get_property(OBJECT *obj, \/**< a pointer to the object *\/$/;"	f
gl_get_property	gridlabd.h	507;"	d
gl_get_reference	gridlabd.h	571;"	d
gl_get_string	gridlabd.h	655;"	d
gl_get_string_by_name	gridlabd.h	653;"	d
gl_get_unit	gridlabd.h	604;"	d
gl_get_value	gridlabd.h	/^inline int gl_get_value(OBJECT *obj, \/**< the object from which to get the data *\/$/;"	f
gl_get_value	gridlabd.h	521;"	d
gl_get_value_by_name	gridlabd.h	/^inline int gl_get_value_by_name(OBJECT *obj,$/;"	f
gl_get_value_by_name	gridlabd.h	583;"	d
gl_gethour	gridlabd.h	/^inline int gl_gethour(TIMESTAMP t)$/;"	f
gl_getvalue	gridlabd.h	/^inline char *gl_getvalue(OBJECT *obj,$/;"	f
gl_getweekday	gridlabd.h	/^inline int gl_getweekday(TIMESTAMP t)$/;"	f
gl_global_create	gridlabd.h	846;"	d
gl_global_find	gridlabd.h	861;"	d
gl_global_getvar	gridlabd.h	856;"	d
gl_global_setvar	gridlabd.h	851;"	d
gl_globalclock	gridlabd.h	777;"	d
gl_lerp	gridlabd.h	1000;"	d
gl_loadshape_create	gridlabd.h	/^inline loadshape *gl_loadshape_create(SCHEDULE *s)$/;"	f
gl_localtime	gridlabd.h	819;"	d
gl_malloc	gridlabd.h	299;"	d
gl_mktime	gridlabd.h	789;"	d
gl_module_depends	gridlabd.h	/^inline int gl_module_depends(char *name, \/**< module name *\/$/;"	f
gl_module_depends	gridlabd.h	345;"	d
gl_name	gridlabd.h	/^inline char* gl_name(OBJECT *my, char *buffer, size_t size)$/;"	f
gl_name_object	gridlabd.h	620;"	d
gl_object_isa	gridlabd.h	/^inline bool gl_object_isa(OBJECT *obj, \/**< object to test *\/$/;"	f
gl_object_isa	gridlabd.h	407;"	d
gl_output	gridlabd.h	258;"	d
gl_parsetime	gridlabd.h	782;"	d
gl_printtime	gridlabd.h	784;"	d
gl_pseudorandomvalue	gridlabd.h	727;"	d
gl_publish_delegate	gridlabd.h	497;"	d
gl_publish_function	gridlabd.h	/^inline FUNCTION *gl_publish_function(CLASS *oclass, \/**< class to which function belongs *\/$/;"	f
gl_publish_function	gridlabd.h	426;"	d
gl_publish_variable	gridlabd.h	413;"	d
gl_qerp	gridlabd.h	1006;"	d
gl_random_bernoulli	gridlabd.h	747;"	d
gl_random_beta	gridlabd.h	765;"	d
gl_random_exponential	gridlabd.h	762;"	d
gl_random_gamma	gridlabd.h	764;"	d
gl_random_lognormal	gridlabd.h	742;"	d
gl_random_normal	gridlabd.h	737;"	d
gl_random_pareto	gridlabd.h	752;"	d
gl_random_rayleigh	gridlabd.h	767;"	d
gl_random_sampled	gridlabd.h	757;"	d
gl_random_triangle	gridlabd.h	763;"	d
gl_random_uniform	gridlabd.h	732;"	d
gl_random_weibull	gridlabd.h	766;"	d
gl_randomtype	gridlabd.h	717;"	d
gl_randomvalue	gridlabd.h	722;"	d
gl_register_class	gridlabd.h	365;"	d
gl_register_type	gridlabd.h	492;"	d
gl_run_aggregate	gridlabd.h	700;"	d
gl_schedule_create	gridlabd.h	/^inline SCHEDULE *gl_schedule_create(char *name, char *definition)$/;"	f
gl_schedule_dtnext	gridlabd.h	/^inline long gl_schedule_dtnext(SCHEDULE *sch, SCHEDULEINDEX index)$/;"	f
gl_schedule_find	gridlabd.h	/^inline SCHEDULE *gl_schedule_find(char *name)$/;"	f
gl_schedule_index	gridlabd.h	/^inline SCHEDULEINDEX gl_schedule_index(SCHEDULE *sch, TIMESTAMP ts)$/;"	f
gl_schedule_value	gridlabd.h	/^inline double gl_schedule_value(SCHEDULE *sch, SCHEDULEINDEX index)$/;"	f
gl_set_dependent	gridlabd.h	/^inline int gl_set_dependent(OBJECT *obj, \/**< object to set dependency *\/$/;"	f
gl_set_dependent	gridlabd.h	441;"	d
gl_set_parent	gridlabd.h	/^inline int gl_set_parent(OBJECT *obj, \/**< object to set parent of *\/$/;"	f
gl_set_parent	gridlabd.h	457;"	d
gl_set_rank	gridlabd.h	/^inline int gl_set_rank(OBJECT *obj, \/**< object to change rank *\/$/;"	f
gl_set_rank	gridlabd.h	473;"	d
gl_set_value	gridlabd.h	/^inline int gl_set_value(OBJECT *obj, \/**< the object to alter *\/$/;"	f
gl_set_value	gridlabd.h	/^template <class T> inline int gl_set_value(OBJECT *obj, \/\/\/< the object whose property value is being obtained$/;"	f
gl_set_value	gridlabd.h	535;"	d
gl_set_value_by_name	gridlabd.h	599;"	d
gl_set_value_by_type	gridlabd.h	523;"	d
gl_strftime	gridlabd.h	/^inline char *gl_strftime(DATETIME *dt, char *buffer, int size) { return callback->time.strdatetime(dt,buffer,size)?buffer:NULL;};$/;"	f
gl_strftime	gridlabd.h	/^inline char *gl_strftime(TIMESTAMP ts)$/;"	f
gl_strtime	gridlabd.h	794;"	d
gl_testmsg	gridlabd.h	282;"	d
gl_todays	gridlabd.h	799;"	d
gl_tohours	gridlabd.h	804;"	d
gl_tominutes	gridlabd.h	809;"	d
gl_toseconds	gridlabd.h	814;"	d
gl_verbose	gridlabd.h	253;"	d
gl_warning	gridlabd.h	263;"	d
gldStack	load_xml_handle.h	/^	gldStack(){next = NULL; clear();}$/;"	f	class:gldStack
gldStack	load_xml_handle.h	/^	gldStack(gldStack *ptr){next = ptr; clear();}$/;"	f	class:gldStack
gldStack	load_xml_handle.h	/^class gldStack{$/;"	c
gld_loadHndl	load_xml_handle.h	/^class gld_loadHndl : public DefaultHandler, public XMLFormatTarget {$/;"	c
gld_state	load_xml_handle.h	/^} gld_state;$/;"	t	typeref:enum:__anon30
global	object.h	/^	} global;$/;"	m	struct:s_callbacks	typeref:struct:s_callbacks::__anon38
global_block	load.c	/^char global_block[65536] = "";$/;"	v
global_clock	object.h	/^	TIMESTAMP *global_clock;$/;"	m	struct:s_callbacks
global_command_line	globals.h	/^GLOBAL char global_command_line[1024]; \/**< The current command-line *\/$/;"	v
global_create	globals.c	/^GLOBALVAR *global_create(char *name, ...){$/;"	f
global_dump	globals.c	/^void global_dump(void)$/;"	f
global_find	globals.c	/^GLOBALVAR *global_find(char *name) \/**< name of global variable to find *\/$/;"	f
global_getnext	globals.c	/^GLOBALVAR *global_getnext(GLOBALVAR *previous){ \/**< a pointer to the previous variable name (NULL for first) *\/$/;"	f
global_getvar	globals.c	/^char *global_getvar(char *name, char *buffer, int size){$/;"	f
global_init	globals.c	/^STATUS global_init(void)$/;"	f
global_setvar	globals.c	/^STATUS global_setvar(char *def, ...) \/**< the definition *\/$/;"	f
global_varlist	globals.c	/^static GLOBALVAR *global_varlist = NULL, *lastvar = NULL;$/;"	v	file:
globalname	gui.h	/^	char globalname[64]; \/\/ ref to variable$/;"	m	struct:s_guientity
globals	module.h	/^	PROPERTY *globals;$/;"	m	struct:s_module_list
gnuplot	gui.h	/^	char gnuplot[4096];	\/\/ gnuplot script$/;"	m	struct:s_guientity
gnuplot	load.c	/^static int gnuplot(PARSER, GUIENTITY *entity)$/;"	f	file:
gridlabd_file	load.c	/^static int gridlabd_file(PARSER)$/;"	f	file:
group	aggregate.h	/^	struct s_findpgm *group; \/**< the find program used to build the aggregation *\/$/;"	m	struct:s_aggregate	typeref:struct:s_aggregate::s_findpgm
groupid	object.h	/^	char32 groupid;$/;"	m	struct:s_object_list
gui	load.c	/^static int gui(PARSER)$/;"	f	file:
gui_X11_start	gui.c	/^void gui_X11_start(void)$/;"	f
gui_cmd_entity	gui.c	/^int gui_cmd_entity(int item, GUIENTITY *entity)$/;"	f
gui_cmd_input_count	gui.c	/^int gui_cmd_input_count(GUIENTITY *entity)$/;"	f
gui_cmd_menu	gui.c	/^void gui_cmd_menu(GUIENTITY *parent)$/;"	f
gui_cmd_prompt	gui.c	/^void gui_cmd_prompt(GUIENTITY *parent)$/;"	f
gui_cmd_start	gui.c	/^void gui_cmd_start(void)$/;"	f
gui_create_entity	gui.c	/^GUIENTITY *gui_create_entity()$/;"	f
gui_default_stream	gui.c	/^static int gui_default_stream(void *ref,char *format,...)$/;"	f	file:
gui_entity	load.c	/^static int gui_entity(PARSER, GUIENTITY *parent)$/;"	f	file:
gui_entity_action	load.c	/^static int gui_entity_action(PARSER, GUIENTITY *parent)$/;"	f	file:
gui_entity_html_close	gui.c	/^static void gui_entity_html_close(GUIENTITY *entity)$/;"	f	file:
gui_entity_html_content	gui.c	/^static void gui_entity_html_content(GUIENTITY *entity)$/;"	f	file:
gui_entity_html_open	gui.c	/^static void gui_entity_html_open(GUIENTITY *entity)$/;"	f	file:
gui_entity_parameter	load.c	/^static int gui_entity_parameter(PARSER, GUIENTITY *entity)$/;"	f	file:
gui_entity_type	load.c	/^static int gui_entity_type(PARSER, GUIENTITYTYPE *type)$/;"	f	file:
gui_get_data	gui.c	/^void *gui_get_data(GUIENTITY *entity)$/;"	f
gui_get_dump	gui.c	/^char *gui_get_dump(GUIENTITY *entity)$/;"	f
gui_get_environment	gui.c	/^char *gui_get_environment(GUIENTITY *entity)$/;"	f
gui_get_last	gui.c	/^GUIENTITY *gui_get_last(void)$/;"	f
gui_get_name	gui.c	/^char *gui_get_name(GUIENTITY *entity)$/;"	f
gui_get_next	gui.c	/^GUIENTITY *gui_get_next(GUIENTITY *entity)$/;"	f
gui_get_object	gui.c	/^OBJECT *gui_get_object(GUIENTITY *entity)$/;"	f
gui_get_parent	gui.c	/^GUIENTITY *gui_get_parent(GUIENTITY *entity)$/;"	f
gui_get_property	gui.c	/^PROPERTY *gui_get_property(GUIENTITY *entity)$/;"	f
gui_get_root	gui.c	/^GUIENTITY *gui_get_root(void)$/;"	f
gui_get_span	gui.c	/^int gui_get_span(GUIENTITY *entity)$/;"	f
gui_get_type	gui.c	/^GUIENTITYTYPE gui_get_type(GUIENTITY *entity)$/;"	f
gui_get_typename	gui.c	/^char *gui_get_typename(GUIENTITY *entity)$/;"	f
gui_get_unit	gui.c	/^UNIT *gui_get_unit(GUIENTITY *entity)$/;"	f
gui_get_value	gui.c	/^char *gui_get_value(GUIENTITY *entity)$/;"	f
gui_get_variable	gui.c	/^GLOBALVAR *gui_get_variable(GUIENTITY *entity)$/;"	f
gui_glm_typename	gui.c	/^char *gui_glm_typename(GUIENTITYTYPE type)$/;"	f
gui_glm_write	gui.c	/^size_t gui_glm_write(FILE *fp, GUIENTITY *entity, int indent)$/;"	f
gui_glm_write_all	gui.c	/^size_t gui_glm_write_all(FILE *fp)$/;"	f
gui_html_output	gui.c	/^static GUISTREAMFN gui_html_output = gui_default_stream;$/;"	v	file:
gui_html_output_all	gui.c	/^STATUS gui_html_output_all(void)$/;"	f
gui_html_output_children	gui.c	/^void gui_html_output_children(GUIENTITY *entity)$/;"	f
gui_html_output_page	gui.c	/^int gui_html_output_page(char *page)$/;"	f
gui_html_source_page	gui.c	/^static int gui_html_source_page(char *source)$/;"	f	file:
gui_html_start	gui.c	/^void gui_html_start(void)$/;"	f
gui_include_element	gui.c	/^void gui_include_element(char *tag, char *options, char *file)$/;"	f
gui_is_action	gui.c	/^int gui_is_action(GUIENTITY *entity)$/;"	f
gui_is_grouping	gui.c	/^int gui_is_grouping(GUIENTITY *entity)$/;"	f
gui_is_header	gui.c	/^int gui_is_header(GUIENTITY *entity)$/;"	f
gui_is_input	gui.c	/^int gui_is_input(GUIENTITY *entity)$/;"	f
gui_is_labeling	gui.c	/^int gui_is_labeling(GUIENTITY *entity)$/;"	f
gui_is_output	gui.c	/^int gui_is_output(GUIENTITY *entity)$/;"	f
gui_last	gui.c	/^static GUIENTITY *gui_last = NULL;$/;"	v	file:
gui_link_globalvar	load.c	/^static int gui_link_globalvar(PARSER, GLOBALVAR **var)$/;"	f	file:
gui_output_html_graph	gui.c	/^static void gui_output_html_graph(GUIENTITY *entity)$/;"	f	file:
gui_output_html_table	gui.c	/^static void gui_output_html_table(GUIENTITY *entity)$/;"	f	file:
gui_output_html_textarea	gui.c	/^static void gui_output_html_textarea(GUIENTITY *entity)$/;"	f	file:
gui_root	gui.c	/^static GUIENTITY *gui_root = NULL;$/;"	v	file:
gui_set_html_stream	gui.c	/^void gui_set_html_stream(void *ref, GUISTREAMFN stream)$/;"	f
gui_set_next	gui.c	/^void gui_set_next(GUIENTITY *entity, GUIENTITY *next)$/;"	f
gui_set_objectname	gui.c	/^void gui_set_objectname(GUIENTITY *entity, char *objectname)$/;"	f
gui_set_options	gui.c	/^void gui_set_options(GUIENTITY *entity, char *options)$/;"	f
gui_set_parent	gui.c	/^void gui_set_parent(GUIENTITY *entity, GUIENTITY *parent)$/;"	f
gui_set_propertyname	gui.c	/^void gui_set_propertyname(GUIENTITY *entity, char *propertyname)$/;"	f
gui_set_source	gui.c	/^void gui_set_source(GUIENTITY *entity, char *source)$/;"	f
gui_set_span	gui.c	/^void gui_set_span(GUIENTITY *entity, int span)$/;"	f
gui_set_srcref	gui.c	/^void gui_set_srcref(GUIENTITY *entity, char *filename, int linenum)$/;"	f
gui_set_type	gui.c	/^void gui_set_type(GUIENTITY *entity, GUIENTITYTYPE type)$/;"	f
gui_set_unit	gui.c	/^void gui_set_unit(GUIENTITY *entity, char *unit)$/;"	f
gui_set_value	gui.c	/^void gui_set_value(GUIENTITY *entity, char *value)$/;"	f
gui_set_variablename	gui.c	/^void gui_set_variablename(GUIENTITY *entity, char *globalname)$/;"	f
gui_wait	gui.c	/^void gui_wait(void)$/;"	f
h	unit.c	/^static double h = 6.62617636e-34;	\/**< J\/Hz *\/$/;"	v	file:
h	unit.h	/^	double c,e,h,k,m,s,a,b; \/**< the unit parameters *\/$/;"	m	struct:s_unit
hLib	module.h	/^	void *hLib;$/;"	m	struct:s_module_list
handler_stop	kill.c	/^static int handler_stop = 0;$/;"	v	file:
handlers	exception.c	/^EXCEPTIONHANDLER *handlers = NULL;$/;"	v
hard_event	exec.h	/^	int hard_event; \/**< non-zero for hard events that can effect the advance step-to *\/$/;"	m	struct:sync_data
header_list	load.c	/^INCLUDELIST *header_list = NULL;$/;"	v
heatgain	enduse.h	/^	double heatgain;			\/* internal heat from load (Btu\/h) *\/$/;"	m	struct:s_enduse
heatgain_fraction	enduse.h	/^	double heatgain_fraction;	\/* fraction of power that goes to internal heat (pu Btu\/h) *\/$/;"	m	struct:s_enduse
height	gui.h	/^	int height; \/\/ height spec$/;"	m	struct:s_guientity
hex	server.c	/^static char hex(char c)$/;"	f	file:
high	loadshape.h	/^			double low, high;			\/**< the low and high values in the schedule *\/$/;"	m	struct:s_loadshape::__anon24::__anon29
hit_count	find.h	/^	unsigned int hit_count;$/;"	m	struct:s_findlist
hour	timestamp.c	/^	int month, nth, day, hour, minute;$/;"	m	struct:__anon60	file:
hour	timestamp.h	/^	unsigned short hour; \/**< hour (0-23) *\/$/;"	m	struct:s_datetime
http_action_request	server.c	/^int http_action_request(HTTP *http,char *action)$/;"	f
http_close	server.c	/^static void http_close(HTTP *http)$/;"	f	file:
http_create	server.c	/^static HTTP *http_create(SOCKET s)$/;"	f	file:
http_decode	server.c	/^void http_decode(char *buffer)$/;"	f
http_favicon	server.c	/^int http_favicon(http)$/;"	f
http_format	server.c	/^static int http_format(HTTP *http, char *format, ...)$/;"	f	file:
http_get_realtime	server.c	/^void http_get_realtime(HTTP * http)$/;"	f
http_get_simtime	server.c	/^void http_get_simtime(HTTP * http)$/;"	f
http_gui_request	server.c	/^int http_gui_request(HTTP *http,char *uri)$/;"	f
http_list_request	server.c	/^int http_list_request(HTTP *http)$/;"	f
http_mime	server.c	/^static void http_mime(HTTP *http, char *path)$/;"	f	file:
http_output_request	server.c	/^int http_output_request(HTTP *http,char *uri)$/;"	f
http_response	server.c	/^void http_response(SOCKET fd)$/;"	f
http_send	server.c	/^static void http_send(HTTP *http)$/;"	f	file:
http_set_realtime	server.c	/^http_set_realtime(HTTP *http, char *uri)$/;"	f
http_status	server.c	/^static void http_status(HTTP *http, char *status)$/;"	f	file:
http_type	server.c	/^static void http_type(HTTP *http, char *type)$/;"	f	file:
http_unquote	server.c	/^char *http_unquote(char *buffer)$/;"	f
http_write	server.c	/^static void http_write(HTTP *http, char *data, int len)$/;"	f	file:
http_xml_request	server.c	/^int http_xml_request(HTTP *http,char *uri)$/;"	f
i	complex.h	/^	double i; \/**< the imaginary part *\/$/;"	m	class:complex
i	complex.h	/^	double i; \/**< the imaginary part *\/$/;"	m	struct:__anon13
id	exception.h	/^	int id; \/**< the exception handler id *\/$/;"	m	struct:s_exception_handler
id	index.h	/^	unsigned int id;	\/**< the index id *\/$/;"	m	struct:s_index
id	load.h	/^	char256 id;$/;"	m	struct:s_unresolved
id	object.h	/^	OBJECTNUM id; \/**< object id number; globally unique *\/$/;"	m	struct:s_object_list
impedance_fraction	enduse.h	/^	double impedance_fraction;	\/* constant impedance fraction (pu load) *\/$/;"	m	struct:s_enduse
import	load.c	/^static int import(PARSER)$/;"	f	file:
import_file	module.h	/^	int (*import_file)(char *file);$/;"	m	struct:s_module_list
in_svc	object.h	/^	TIMESTAMP in_svc, \/**< time at which object begin's operating *\/$/;"	m	struct:s_object_list
include_fail	load.c	/^static int include_fail = 0;$/;"	v	file:
include_file	load.c	/^static int include_file(char *incname, char *buffer, int size, int _linenum)$/;"	f	file:
include_list	load.c	/^INCLUDELIST *include_list = NULL;$/;"	v
incr	exec.c	/^    int incr;$/;"	m	struct:arg_data	file:
indent	stream.c	/^static char indent[256]="";$/;"	v	file:
indent_less	stream.c	/^void indent_less() { if (indent[0]!='\\0') indent[strlen(indent)-1] = '\\0';}$/;"	f
indent_more	stream.c	/^void indent_more() { if (strlen(indent)<sizeof(indent)\/sizeof(indent[0])) strcat(indent," ");}$/;"	f
index	load.c	/^	int index;$/;"	m	struct:s_rpn_func	file:
index	object.h	/^		SCHEDULEINDEX (*index)(SCHEDULE *sch, TIMESTAMP ts);$/;"	m	struct:s_callbacks::__anon41
index	schedule.h	/^	unsigned char index[14][366*24*60];	\/**< the schedule index (enough room for all 14 annual calendars to 1 minute resolution) *\/$/;"	m	struct:s_schedule
index_create	index.c	/^INDEX *index_create(int first_ordinal, \/**< the first ordinal *\/$/;"	f
index_insert	index.c	/^STATUS index_insert(INDEX *index,	\/**< the index to which the item is added *\/$/;"	f
index_shuffle	index.c	/^void index_shuffle(INDEX *index)	\/**< the index to shuffle *\/$/;"	f
init	class.h	/^	FUNCTIONADDR init;$/;"	m	struct:s_class_list
init	object.h	/^		int (*init)(struct s_loadshape *s);$/;"	m	struct:s_callbacks::__anon42
init_all	exec.c	/^static STATUS init_all(void)$/;"	f	file:
init_block	load.c	/^char init_block[65535] = "";$/;"	v
init_objects	test_callbacks.h	/^	STATUS (*init_objects)(void);$/;"	m	struct:s_test_callbacks
inline	lock.h	62;"	d
int16	class.h	/^typedef short int16; \/** 16-bit integers *\/$/;"	t
int16_var	object.h	/^		int16 *(*int16_var)(OBJECT *obj, PROPERTY *prop);$/;"	m	struct:s_callbacks::s_objvar_struct
int16_var	object.h	/^		int16 *(*int16_var)(OBJECT *obj, char *name);$/;"	m	struct:s_callbacks::s_objvar_name_struct
int32	class.h	/^typedef int int32; \/* 32-bit integers *\/$/;"	t
int32_var	object.h	/^		int32 *(*int32_var)(OBJECT *obj, PROPERTY *prop);$/;"	m	struct:s_callbacks::s_objvar_struct
int32_var	object.h	/^		int32 *(*int32_var)(OBJECT *obj, char *name);$/;"	m	struct:s_callbacks::s_objvar_name_struct
int64	platform.h	19;"	d
int64	platform.h	42;"	d
int64_var	object.h	/^		int64 *(*int64_var)(OBJECT *obj, PROPERTY *prop);$/;"	m	struct:s_callbacks::s_objvar_struct
int64_var	object.h	/^		int64 *(*int64_var)(OBJECT *obj, char *name);$/;"	m	struct:s_callbacks::s_objvar_name_struct
int8	class.h	/^typedef char int8; \/** 8-bit integers *\/$/;"	t
int_16	find.c	/^	COMPAREFUNC pointer, integer, real, string, int_16, int_32, int_64;	\/*	int_size to avoid #define int64 (platform.h) *\/$/;"	m	struct:__anon54	file:
int_32	find.c	/^	COMPAREFUNC pointer, integer, real, string, int_16, int_32, int_64;	\/*	int_size to avoid #define int64 (platform.h) *\/$/;"	m	struct:__anon54	file:
int_64	find.c	/^	COMPAREFUNC pointer, integer, real, string, int_16, int_32, int_64;	\/*	int_size to avoid #define int64 (platform.h) *\/$/;"	m	struct:__anon54	file:
integer	cmex.h	/^		int *integer;$/;"	m	union:__anon10::__anon11
integer	find.c	/^	COMPAREFUNC pointer, integer, real, string, int_16, int_32, int_64;	\/*	int_size to avoid #define int64 (platform.h) *\/$/;"	m	struct:__anon54	file:
integer	find.c	/^	COMPAREFUNC pointer, integer, real, string;$/;"	m	struct:__anon53	file:
integer	find.c	/^static int integer(PARSER, int64 *value)$/;"	f	file:
integer	find.h	/^	int64 integer;$/;"	m	union:__anon16
integer	load.c	/^static int integer(PARSER, int64 *value)$/;"	f	file:
integer16	load.c	/^static int integer16(PARSER, int16 *value)$/;"	f	file:
integer32	load.c	/^static int integer32(PARSER, int32 *value)$/;"	f	file:
interpolate	object.h	/^	} interpolate;$/;"	m	struct:s_callbacks	typeref:struct:s_callbacks::__anon44
interpolate_linear	interpolate.c	/^double interpolate_linear(double t, double x0, double y0, double x1, double y1){$/;"	f
interpolate_quadratic	interpolate.c	/^double interpolate_quadratic(double t, double x0, double y0, double x1, double y1, double x2, double y2){$/;"	f
invar_types	find.c	/^static FINDTYPE invar_types[] = {FT_ID, FT_SIZE, FT_CLASS, FT_PARENT, FT_RANK, FT_NAME, FT_LAT, FT_LONG, FT_INSVC, FT_OUTSVC, FT_MODULE,  0};$/;"	v	file:
is_dst	timestamp.h	/^	unsigned short is_dst; \/**< 0=std, 1=dst *\/$/;"	m	struct:s_datetime
is_int	load.c	/^int is_int(PROPERTYTYPE pt){$/;"	f
isa	class.h	/^	FUNCTIONADDR isa;$/;"	m	struct:s_class_list
isdst	timestamp.c	/^int isdst(TIMESTAMP t)$/;"	f
isfinite	platform.h	38;"	d
isfinite	platform.h	50;"	d
isnan	module.c	577;"	d	file:
isnan	object.c	32;"	d	file:
isnan	platform.h	26;"	d
item	exec.c	/^    void *item;$/;"	m	struct:arg_data	file:
iteration_counter	exec.c	/^int iteration_counter = 0;   \/* number of redos completed *\/$/;"	v
k	unit.c	/^static double k = 1.38066244e-23;	\/**< J\/K *\/$/;"	v	file:
k	unit.h	/^	double c,e,h,k,m,s,a,b; \/**< the unit parameters *\/$/;"	m	struct:s_unit
keys	globals.c	/^	KEYWORD *keys;$/;"	m	struct:s_varmap	file:
keyword	load_xml_handle.h	/^	char keyword[64];$/;"	m	class:gldStack
keywords	class.h	/^	KEYWORD *keywords; \/**< keyword list, if any; \\p NULL if none (only for set and enumeration types)*\/$/;"	m	struct:s_property_map
kill	kill.c	/^int kill(unsigned short pid,	\/**< the window process id *\/$/;"	f
kill_starthandler	kill.c	/^void kill_starthandler(void)$/;"	f
kill_stophandler	kill.c	/^void kill_stophandler(void)$/;"	f
kml_document	kml.c	/^int kml_document(FILE *fp)$/;"	f
kml_dump	kml.c	/^int kml_dump(char *filename)$/;"	f
kml_output	kml.c	/^int kml_output(FILE *fp)$/;"	f
kmldump	module.h	/^	int (*kmldump)(FILE*fp,OBJECT*);$/;"	m	struct:s_module_list
l	stream.c	/^static unsigned long l;$/;"	v	file:
last	aggregate.h	/^	struct s_findlist *last; \/**< the result of the last run *\/$/;"	m	struct:s_aggregate	typeref:struct:s_aggregate::s_findlist
last	list.h	/^	LISTITEM *last;$/;"	m	struct:s_list
last	load_xml_handle.h	/^	int first, last;$/;"	m	class:gld_loadHndl
last_breakpoint	debug.c	/^	*last_breakpoint=NULL; \/**< pointer to the last breakpoint *\/$/;"	v	file:
last_class	class.c	/^static CLASS *last_class = NULL; \/**< last class in class list *\/$/;"	v	file:
last_module	module.c	/^MODULE *last_module = NULL;$/;"	v
last_object	object.c	/^static OBJECT *last_object = NULL;$/;"	v	file:
last_ordinal	index.h	/^	int last_ordinal;	\/**< the last ordinal in the list *\/$/;"	m	struct:s_index
last_used	index.h	/^	int last_used;		\/**< the last ordinal in use *\/$/;"	m	struct:s_index
last_watchpoint	debug.c	/^	*last_watchpoint=NULL; \/**< a pointer to the last watchpoint *\/$/;"	v	file:
lastvar	globals.c	/^static GLOBALVAR *global_varlist = NULL, *lastvar = NULL;$/;"	v	file:
latitude	object.h	/^	double latitude, longitude; \/**< object's geo-coordinates *\/$/;"	m	struct:s_object_list
leave_critical_section	threadpool.c	133;"	d	file:
leave_critical_section	threadpool.c	148;"	d	file:
leave_critical_section	threadpool.c	80;"	d	file:
left	cmdarg.c	/^	struct s_pntree *left, *right;$/;"	m	struct:s_pntree	typeref:struct:s_pntree::s_pntree	file:
legal_license	legal.c	/^STATUS legal_license(void)$/;"	f
legal_notice	legal.c	/^STATUS legal_notice(void)$/;"	f
len	server.c	/^    size_t len;$/;"	m	struct:s_http	file:
len	unit.c	/^	unsigned char len;$/;"	m	struct:s_unitscalar	file:
library	load.c	/^static int library(PARSER)$/;"	f	file:
limit	cmex.h	/^	int limit;$/;"	m	struct:__anon10
line	load.h	/^	unsigned int line;$/;"	m	struct:s_unresolved
line	load.h	/^	unsigned int line;$/;"	m	struct:s_unresolved_func
line_spec	load.c	/^static int line_spec(PARSER)$/;"	f	file:
linear	object.h	/^		double (*linear)(double t, double x0, double y0, double x1, double y1);$/;"	m	struct:s_callbacks::__anon44
linear_transform	load.c	/^static int linear_transform(PARSER, XFORMSOURCE *xstype, void **source, double *scale, double *bias, OBJECT *from)$/;"	f	file:
linenum	load.c	/^static unsigned int linenum=1;$/;"	v	file:
linenum	unit.c	/^static int linenum = 0;$/;"	v	file:
list	threadpool.c	/^	LISTITEM *list;$/;"	m	struct:threadpool	file:
list_append	list.c	/^LISTITEM *list_append(LIST *list, \/**< a pointer to the LIST structure to which the item it to be appended *\/$/;"	f
list_create	list.c	/^LIST *list_create(void)$/;"	f
list_destroy	list.c	/^void list_destroy(LIST *list) \/**< a pointer to the LIST structure to destroy *\/$/;"	f
list_details	debug.c	/^static int list_details = 0; \/**< flag indicating that listing includes details *\/$/;"	v	file:
list_inactive	debug.c	/^static int list_inactive = 1; \/**< flag indicating that listing includes inactive objects *\/$/;"	v	file:
list_object	debug.c	/^static void list_object(OBJECT *obj, PASSCONFIG pass)$/;"	f	file:
list_shuffle	list.c	/^void list_shuffle(LIST *list)$/;"	f
list_sync	debug.c	/^static int list_sync = 1; \/**< flag indicating that listing includes objects that have syncs *\/$/;"	v	file:
list_unnamed	debug.c	/^static int list_unnamed = 1; \/**< flag indicating that listing includes unnamed objects *\/$/;"	v	file:
literal	find.c	/^static int literal(PARSER, char *text)$/;"	f	file:
literal	load.c	/^static int literal(PARSER, char *text)$/;"	f	file:
load	loadshape.h	/^	double load;		\/**< the actual load magnitude *\/$/;"	m	struct:s_loadshape
load_fp	debug.c	/^FILE *load_fp; \/**< the file from which commands are read (see \\p script) *\/$/;"	v
load_from_file	debug.c	/^int load_from_file = 0; \/** flag whether commands are being read from a \\p script file (see #load_fp) *\/$/;"	v
load_get_index	load.c	/^\/*static*\/ OBJECT *load_get_index(OBJECTNUM id)$/;"	f
load_java_module	matlab.c	/^MODULE *load_java_module(const char *file, \/**< module filename, searches \\p PATH *\/$/;"	f
load_latitude	load.c	/^double load_latitude(char *buffer)$/;"	f
load_longitude	load.c	/^double load_longitude(char *buffer)$/;"	f
load_module_list	cmdarg.c	/^STATUS load_module_list(FILE *fd,int* test_mod_num)$/;"	f
load_python_module	matlab.c	/^MODULE *load_python_module(const char *file, \/**< module filename, searches \\p PATH *\/$/;"	f
load_ready	load_xml_handle.h	/^	bool load_ready;$/;"	m	class:gld_loadHndl
load_resolve_all	load.c	/^\/*static*\/ int load_resolve_all()$/;"	f
load_set_index	load.c	/^\/*static*\/ STATUS load_set_index(OBJECT *obj, OBJECTNUM id)$/;"	f
load_state	load_xml_handle.h	/^	bool load_state;$/;"	m	class:gld_loadHndl
load_tzspecs	timestamp.c	/^void load_tzspecs(char *tz){$/;"	f
loadall	load.c	/^STATUS loadall(char *file){$/;"	f
loadall_glm	load.c	/^STATUS loadall_glm(char *file) \/**< a pointer to the first character in the file name string *\/$/;"	f
loadall_glm_roll	load.c	/^STATUS loadall_glm_roll(char *file) \/**< a pointer to the first character in the file name string *\/$/;"	f
loadshape	loadshape.h	/^typedef struct s_loadshape loadshape;$/;"	t	typeref:struct:s_loadshape
loadshape	object.h	/^	} loadshape;$/;"	m	struct:s_callbacks	typeref:struct:s_callbacks::__anon42
loadshape_create	loadshape.c	/^int loadshape_create(loadshape *data)$/;"	f
loadshape_init	loadshape.c	/^int loadshape_init(loadshape *ls) \/**< load shape *\/$/;"	f
loadshape_initall	loadshape.c	/^int loadshape_initall(void)$/;"	f
loadshape_list	loadshape.c	/^static loadshape *loadshape_list = NULL;$/;"	v	file:
loadshape_recalc	loadshape.c	/^void loadshape_recalc(loadshape *ls)$/;"	f
loadshape_sync	loadshape.c	/^TIMESTAMP loadshape_sync(loadshape *ls, TIMESTAMP t1)$/;"	f
loadshape_syncall	loadshape.c	/^TIMESTAMP loadshape_syncall(TIMESTAMP t1)$/;"	f
loadshape_test	loadshape.c	/^int loadshape_test(void)$/;"	f
local_callbacks	test_framework.h	/^TEST_CALLBACKS *local_callbacks;$/;"	v
local_datetime	object.h	/^		int (*local_datetime)(TIMESTAMP ts, DATETIME *dt);$/;"	m	struct:s_callbacks::__anon36
local_datetime	timestamp.c	/^int local_datetime(TIMESTAMP ts, DATETIME *dt)$/;"	f
local_tzoffset	timestamp.c	/^int local_tzoffset(TIMESTAMP t)$/;"	f
locale_pop	local.c	/^void locale_pop(void)$/;"	f
locale_push	local.c	/^void locale_push(void)$/;"	f
locator	load_xml_handle.h	/^	Locator const *locator;$/;"	m	class:gld_loadHndl
lock	lock.h	/^static inline void lock(unsigned int *lock)$/;"	f
lock	object.h	/^	unsigned int lock; \/**< object lock *\/$/;"	m	struct:s_object_list
lock_count	exec.c	/^int64 lock_count = 0, lock_spin = 0;$/;"	v
lock_count	module.c	/^int64 lock_count;$/;"	v
lock_count	object.h	/^	int64 *lock_count, *lock_spin;$/;"	m	struct:s_callbacks
lock_spin	exec.c	/^int64 lock_count = 0, lock_spin = 0;$/;"	v
lock_spin	module.c	/^int64 lock_spin;$/;"	v
lock_spin	object.h	/^	int64 *lock_count, *lock_spin;$/;"	m	struct:s_callbacks
lognormal	object.h	/^		double (*lognormal)(double m, double s);$/;"	m	struct:s_callbacks::__anon35
longitude	object.h	/^	double latitude, longitude; \/**< object's geo-coordinates *\/$/;"	m	struct:s_object_list
low	loadshape.h	/^			double low, high;			\/**< the low and high values in the schedule *\/$/;"	m	struct:s_loadshape::__anon24::__anon29
m	unit.c	/^static double m = 0.910953447e-30;	\/**< kg *\/$/;"	v	file:
m	unit.h	/^	double c,e,h,k,m,s,a,b; \/**< the unit parameters *\/$/;"	m	struct:s_unit
macro_line	load.c	/^static int macro_line[64];$/;"	v	file:
mag	aggregate.c	/^double mag(complex *x)$/;"	f
magic	class.h	/^	CLASSMAGIC magic;$/;"	m	struct:s_class_list
magic	enduse.h	/^	unsigned int magic;$/;"	m	struct:s_enduse
main	main.c	/^int main(int argc, \/**< the number entries on command-line argument list \\p argv *\/$/;"	f
main	threadpool.c	/^int main(int argc, char *argv[])$/;"	f
major	module.h	/^	unsigned short major;$/;"	m	struct:s_module_list
make_fieldname	cmex.c	/^static char *make_fieldname(char *str)$/;"	f	file:
make_handle	cmex.c	/^static mxArray *make_handle(MEXHANDLETYPE type, void *ptr)$/;"	f	file:
malloc	object.h	/^	void *(*malloc)(size_t);$/;"	m	struct:s_callbacks
malloc_lock	module.c	/^static int malloc_lock = 0;$/;"	v	file:
map	globals.c	/^} map[] = {$/;"	v	typeref:struct:s_varmap	file:
map	random.c	/^} *p, map[] = {$/;"	v	typeref:struct:__anon55	file:
mark_line	load.c	/^static void mark_line()$/;"	f	file:
mark_linex	load.c	/^static void mark_linex(char *filename, int linenum)$/;"	f	file:
match	match.c	/^int match(char *regexp, char *text){$/;"	f
matchhere	match.c	/^int matchhere(char *regexp, char *text){$/;"	f
matchhere_orig	match.c	/^int matchhere_orig(char *regexp, char *text){$/;"	f
matchstar	match.c	/^int matchstar(int c, char *regexp, char *text){$/;"	f
matlab_startup	matlab.c	/^STATUS matlab_startup(int argc, char *argv)$/;"	f
max	exec.h	41;"	d
max	platform.h	48;"	d
max	random.c	/^static double max(double sample[], unsigned int count)$/;"	f	file:
max	random.c	657;"	d	file:
max	server.c	/^    size_t max;$/;"	m	struct:s_http	file:
mean	random.c	/^static double mean(double sample[], unsigned int count)$/;"	f	file:
mexFunction	cmex.c	/^void mexFunction( int nlhs, mxArray *plhs[],$/;"	f
microsecond	timestamp.h	/^	unsigned int microsecond; \/**< usecond (0-999999) *\/$/;"	m	struct:s_datetime
min	platform.h	29;"	d
min	platform.h	47;"	d
min	random.c	/^static double min(double sample[], unsigned int count)$/;"	f	file:
min	random.c	643;"	d	file:
minor	module.h	/^	unsigned short minor;$/;"	m	struct:s_module_list
minute	timestamp.c	/^	int month, nth, day, hour, minute;$/;"	m	struct:__anon60	file:
minute	timestamp.h	/^	unsigned short minute; \/**< minute (0-59) *\/$/;"	m	struct:s_datetime
minutes	schedule.h	/^	unsigned int minutes[MAXBLOCKS];	\/**< the total number of minutes associate with each block *\/$/;"	m	struct:s_schedule
mkdatetime	object.h	/^		TIMESTAMP (*mkdatetime)(DATETIME *dt);$/;"	m	struct:s_callbacks::__anon36
mkdatetime	timestamp.c	/^TIMESTAMP mkdatetime(DATETIME *dt)$/;"	f
mkdir	load.c	490;"	d	file:
mkdirs	load.c	/^static int mkdirs(char *path)$/;"	f	file:
mod	debug.c	/^		MODULE *mod; \/**< criteria for a module breakpoint *\/$/;"	m	union:s_breakpoint::__anon52	file:
modhelp_alpha	cmdarg.c	/^void modhelp_alpha(pntree **ctree, CLASS *oclass){$/;"	f
modtime	load.c	/^static time_t modtime = 0;$/;"	v	file:
modulated	loadshape.h	/^		} modulated;$/;"	m	union:s_loadshape::__anon24	typeref:struct:s_loadshape::__anon24::__anon27
modulation	loadshape.h	/^			MACHINEMODULATIONTYPE modulation; \/**< the type of modulation used *\/$/;"	m	struct:s_loadshape::__anon24::__anon27
module	class.h	/^	MODULE *module; $/;"	m	struct:s_class_list
module	load_xml_handle.h	/^	MODULE *module;$/;"	m	class:gld_loadHndl
module_block	load.c	/^static int module_block(PARSER)$/;"	f	file:
module_check	module.c	/^int module_check(MODULE *mod)$/;"	f
module_checkall	module.c	/^int module_checkall(void)$/;"	f
module_cmdargs	module.c	/^int module_cmdargs(int argc, char **argv)$/;"	f
module_depends	module.c	/^int module_depends(char *name, unsigned char major, unsigned char minor, unsigned short build)$/;"	f
module_dumpall	module.c	/^int module_dumpall(void)$/;"	f
module_find	module.c	/^MODULE *module_find(char *modname)$/;"	f
module_find	object.h	/^	MODULE *(*module_find)(char *name);$/;"	m	struct:s_callbacks
module_free	module.c	/^void module_free(void *ptr)$/;"	f
module_get_exe_path	module.c	/^int module_get_exe_path(char *buf, int len){$/;"	f
module_get_first	module.c	/^MODULE *module_get_first(void)$/;"	f
module_get_path	module.c	/^int module_get_path(char *buf, int len, MODULE *mod){$/;"	f
module_getvar	module.c	/^void* module_getvar(MODULE *mod, char *varname, char *value, unsigned int size)$/;"	f
module_getvar_addr	module.c	/^double* module_getvar_addr(MODULE *mod, char *varname)$/;"	f
module_getvar_old	module.c	/^void* module_getvar_old(MODULE *mod, char *varname, char *value, unsigned int size)$/;"	f
module_import	module.c	/^int module_import(MODULE *mod, char *filename)$/;"	f
module_libinfo	module.c	/^void module_libinfo(char *module_name)$/;"	f
module_load	module.c	/^MODULE *module_load(const char *file, \/**< module filename, searches \\p PATH *\/$/;"	f
module_malloc	module.c	/^void *module_malloc(size_t size)$/;"	f
module_name	load_xml_handle.h	/^	char module_name[64];$/;"	m	class:gld_loadHndl
module_properties	load.c	/^static int module_properties(PARSER, MODULE *mod)$/;"	f	file:
module_save	module.c	/^int module_save(MODULE *mod, char *filename)$/;"	f
module_saveall	module.c	/^int module_saveall(FILE *fp)$/;"	f
module_saveall_xml	module.c	/^int module_saveall_xml(FILE *fp){$/;"	f
module_saveall_xml_old	module.c	/^int module_saveall_xml_old(FILE *fp)$/;"	f
module_saveobj_xml	module.c	/^int module_saveobj_xml(FILE *fp, MODULE *mod){ \/**< the stream to write to *\/$/;"	f
module_setvar	module.c	/^int module_setvar(MODULE *mod, char *varname, char *value)$/;"	f
module_test	module.h	/^	int (*module_test)(TEST_CALLBACKS *callbacks,int argc,char* argv[]);$/;"	m	struct:s_module_list
module_type	object.h	/^    char *module_type;$/;"	m	struct:string_linked_list
month	timestamp.c	/^	int month, nth, day, hour, minute;$/;"	m	struct:__anon60	file:
month	timestamp.h	/^	unsigned short month; \/**< month (1-12) *\/$/;"	m	struct:s_datetime
msg	exception.h	/^	char msg[1024]; \/**< the message thrown *\/$/;"	m	struct:s_exception_handler
msghandler	kill.c	/^void msghandler(void *param)$/;"	f
mutex	threadpool.c	/^	pthread_mutex_t mutex;$/;"	m	struct:__anon59	file:
my_run	threadpool.c	/^static void my_run(int thread, void *item)$/;"	f	file:
myobject_sync	test_callbacks.h	/^	TIMESTAMP (*myobject_sync)(OBJECT *obj, TIMESTAMP ts,PASSCONFIG pass);$/;"	m	struct:s_test_callbacks
myobject_sync	test_framework.h	/^	static TIMESTAMP myobject_sync(OBJECT *obj, TIMESTAMP ts,PASSCONFIG pass)$/;"	f	class:test_helper
n	stream.c	/^static unsigned short n;$/;"	v	file:
n_schedules	schedule.c	/^static uint32 n_schedules = 0;$/;"	v	file:
name	class.c	/^	char *name; \/**< the property type name *\/$/;"	m	struct:s_property_specs	file:
name	class.h	/^	CLASSNAME name;$/;"	m	struct:s_class_list
name	class.h	/^	FUNCTIONNAME name;$/;"	m	struct:s_function_map
name	class.h	/^	PROPERTYNAME name; \/**< property name *\/$/;"	m	struct:s_property_map
name	class.h	/^	char name[32];$/;"	m	struct:s_keyword
name	cmdarg.c	/^	char *name;$/;"	m	struct:s_pntree	file:
name	cmex.c	/^	char *name;$/;"	m	struct:__anon49	file:
name	enduse.h	/^	char *name;$/;"	m	struct:s_enduse
name	find.c	/^static int name(PARSER, char *result, int size)$/;"	f	file:
name	globals.c	/^	char *name;$/;"	m	struct:s_varmap	file:
name	load.c	/^	char *name;$/;"	m	struct:s_rpn_func	file:
name	load.c	/^static int name(PARSER, char *result, int size)$/;"	f	file:
name	module.h	/^	char name[1024];$/;"	m	struct:s_module_list
name	object.c	/^	char name[64];$/;"	m	struct:s_objecttree	file:
name	object.h	/^	FULLNAME name;$/;"	m	struct:s_namespace
name	object.h	/^	OBJECTNAME name;$/;"	m	struct:s_object_list
name	object.h	/^    char *name;$/;"	m	struct:string_linked_list
name	random.c	/^	char *name;$/;"	m	struct:__anon55	file:
name	schedule.h	/^	char name[64];						\/**< the name of the schedule *\/$/;"	m	struct:s_schedule
name	unit.c	/^	char name[3];$/;"	m	struct:s_unitscalar	file:
name	unit.h	/^	char name[64];		\/**< the name of the unit *\/$/;"	m	struct:s_unit
name_object	object.h	/^	int (*name_object)(OBJECT *obj, char *buffer, int len);$/;"	m	struct:s_callbacks
nameunit	load.c	/^static int nameunit(PARSER,char *result,int size,UNIT **unit)$/;"	f	file:
nargs	random.c	/^	int nargs;$/;"	m	struct:__anon55	file:
neg	find.h	/^	FOUNDACTION pos, neg;$/;"	m	struct:s_findpgm
nesting	load.c	/^static int nesting = 0;$/;"	v	file:
new_list	find.c	/^FINDLIST *new_list(unsigned int n)$/;"	f
newcol	gui.c	/^static void newcol(GUIENTITY *entity)$/;"	f	file:
newrow	gui.c	/^static void newrow(GUIENTITY *entity)$/;"	f	file:
newtable	gui.c	/^static void newtable(GUIENTITY *entity)$/;"	f	file:
next	aggregate.h	/^	struct s_aggregate *next; \/**< the next aggregation in the core's list of aggregators *\/$/;"	m	struct:s_aggregate	typeref:struct:s_aggregate::s_aggregate
next	class.h	/^	struct s_class_list *next;$/;"	m	struct:s_class_list	typeref:struct:s_class_list::s_class_list
next	class.h	/^	struct s_function_map *next;$/;"	m	struct:s_function_map	typeref:struct:s_function_map::s_function_map
next	class.h	/^	struct s_keyword *next;$/;"	m	struct:s_keyword	typeref:struct:s_keyword::s_keyword
next	class.h	/^	struct s_property_map *next; \/**< next property in property list *\/$/;"	m	struct:s_property_map	typeref:struct:s_property_map::s_property_map
next	debug.c	/^	struct s_breakpoint *next; \/**< the next breakpoint in the breakpoint list *\/$/;"	m	struct:s_breakpoint	typeref:struct:s_breakpoint::s_breakpoint	file:
next	debug.c	/^	struct s_watchpoint *next; \/**< the next watchpoint in the watchpoint list *\/$/;"	m	struct:s_watchpoint	typeref:struct:s_watchpoint::s_watchpoint	file:
next	enduse.h	/^	struct s_enduse *next;$/;"	m	struct:s_enduse	typeref:struct:s_enduse::s_enduse
next	exception.h	/^	struct s_exception_handler *next; \/**< the next exception handler *\/$/;"	m	struct:s_exception_handler	typeref:struct:s_exception_handler::s_exception_handler
next	find.h	/^	struct s_findpgm *next;$/;"	m	struct:s_findpgm	typeref:struct:s_findpgm::s_findpgm
next	globals.h	/^	struct s_globalvar *next;$/;"	m	struct:s_globalvar	typeref:struct:s_globalvar::s_globalvar
next	gui.h	/^	struct s_guientity *next;$/;"	m	struct:s_guientity	typeref:struct:s_guientity::s_guientity
next	list.h	/^	struct s_listitem *next;$/;"	m	struct:s_listitem	typeref:struct:s_listitem::s_listitem
next	load.c	/^	struct s_include_list *next;$/;"	m	struct:s_include_list	typeref:struct:s_include_list::s_include_list	file:
next	load.h	/^	struct s_unresolved *next;$/;"	m	struct:s_unresolved	typeref:struct:s_unresolved::s_unresolved
next	load.h	/^	struct s_unresolved_func *next;$/;"	m	struct:s_unresolved_func	typeref:struct:s_unresolved_func::s_unresolved_func
next	load_xml_handle.h	/^	gldStack *next;$/;"	m	class:gldStack
next	loadshape.h	/^	struct s_loadshape *next;	\/* next loadshape in list *\/$/;"	m	struct:s_loadshape	typeref:struct:s_loadshape::s_loadshape
next	local.h	/^	struct s_locale *next;$/;"	m	struct:s_locale	typeref:struct:s_locale::s_locale
next	module.h	/^	struct s_module_list *next;$/;"	m	struct:s_module_list	typeref:struct:s_module_list::s_module_list
next	object.h	/^		OBJECT *(*next)(struct s_findlist *,OBJECT *obj);$/;"	m	struct:s_callbacks::__anon34
next	object.h	/^	struct s_namespace *next;$/;"	m	struct:s_namespace	typeref:struct:s_namespace::s_namespace
next	object.h	/^	struct s_object_list *next; \/**< next object in list *\/$/;"	m	struct:s_object_list	typeref:struct:s_object_list::s_object_list
next	object.h	/^    struct string_linked_list * next;$/;"	m	struct:string_linked_list	typeref:struct:string_linked_list::string_linked_list
next	realtime.c	/^	struct s_eventlist *next;$/;"	m	struct:s_eventlist	typeref:struct:s_eventlist::s_eventlist	file:
next	schedule.h	/^	SCHEDULE *next;	\/* next schedule in list *\/$/;"	m	struct:s_schedule
next	schedule.h	/^	struct s_schedulexform *next;$/;"	m	struct:s_schedulexform	typeref:struct:s_schedulexform::s_schedulexform
next	unit.c	/^	UNITSCALAR *next;$/;"	m	struct:s_unitscalar	file:
next	unit.h	/^	struct s_unit *next; \/**< the next unit is the unit list *\/$/;"	m	struct:s_unit	typeref:struct:s_unit::s_unit
next_index_id	index.c	/^static unsigned int next_index_id = 0;$/;"	v	file:
next_object_id	object.c	/^static OBJECTNUM next_object_id = 0;$/;"	v	file:
next_t	schedule.h	/^	TIMESTAMP next_t;					\/**< the time of the next schedule event *\/$/;"	m	struct:s_schedule
next_t1_sch	schedule.c	/^static TIMESTAMP next_t1_sch, next_t2_sch;$/;"	v	file:
next_t2_sch	schedule.c	/^static TIMESTAMP next_t1_sch, next_t2_sch;$/;"	v	file:
nn	stream.c	/^static unsigned int64 nn;$/;"	v	file:
normal	object.h	/^		double (*normal)(double m, double s);$/;"	m	struct:s_callbacks::__anon35
notify	class.h	/^	FUNCTIONADDR notify;$/;"	m	struct:s_class_list
notify_error	output.c	/^void (*notify_error)(void) = NULL;$/;"	v
nth	timestamp.c	/^	int month, nth, day, hour, minute;$/;"	m	struct:__anon60	file:
num	debug.c	/^	int num; \/**< breakpoint id number *\/$/;"	m	struct:s_breakpoint	file:
num	debug.c	/^	int num; \/**< the watchpoint id number *\/$/;"	m	struct:s_watchpoint	file:
numobjs	class.h	/^		int32 numobjs;$/;"	m	struct:s_class_list::__anon7
oaccess	object.c	/^KEYWORD oaccess[] = {$/;"	v
obj	debug.c	/^		OBJECT *obj; \/**< criteria for an object breakpoint *\/$/;"	m	union:s_breakpoint::__anon52	file:
obj	debug.c	/^	OBJECT *obj; \/**< the object watched, if any *\/$/;"	m	struct:s_watchpoint	file:
obj	gui.h	/^	OBJECT *obj;$/;"	m	struct:s_guientity
obj	load.h	/^	OBJECT *obj;$/;"	m	struct:s_unresolved_func
obj	load_xml_handle.h	/^	OBJECT *obj;$/;"	m	class:gld_loadHndl
obj	object.c	/^	OBJECT *obj;$/;"	m	struct:s_objecttree	file:
obj_vect	load_xml_handle.h	/^	vector<OBJECT *> obj_vect;$/;"	m	class:gld_loadHndl
object	class.h	/^typedef struct s_object_list* object; \/* GridLAB objects *\/$/;"	t	typeref:struct:s_object_list
object_access_property	object.c	/^PROPERTY *object_access_property(){$/;"	f
object_array	object.c	/^static OBJECT **object_array = NULL;$/;"	v	file:
object_array_size	object.c	/^static OBJECTNUM object_array_size = 0;$/;"	v	file:
object_block	load.c	/^static int object_block(PARSER, OBJECT *parent, OBJECT **subobj)$/;"	f	file:
object_build_name	object.c	/^int object_build_name(OBJECT *obj, char *buffer, int len){$/;"	f
object_build_object_array	object.c	/^int object_build_object_array(){$/;"	f
object_close_namespace	object.c	/^int object_close_namespace()$/;"	f
object_commit	object.c	/^int object_commit(OBJECT *obj){$/;"	f
object_count	load_xml_handle.h	/^	int object_count, class_count;$/;"	m	class:gld_loadHndl
object_count	object.h	/^	unsigned int (*object_count)(void);$/;"	m	struct:s_callbacks
object_create_array	object.c	/^OBJECT *object_create_array(CLASS *oclass, \/**< a pointer to the CLASS structure *\/$/;"	f
object_create_foreign	object.c	/^OBJECT *object_create_foreign(OBJECT *obj){ \/**< a pointer to the OBJECT data structure *\/$/;"	f
object_create_single	object.c	/^OBJECT *object_create_single(CLASS *oclass){ \/**< the class of the object *\/$/;"	f
object_current_namespace	object.c	/^NAMESPACE *object_current_namespace()$/;"	f
object_dump	object.c	/^int object_dump(char *outbuffer, \/**< the destination buffer *\/$/;"	f
object_find_by_id	object.c	/^OBJECT *object_find_by_id(OBJECTNUM id){ \/**< object id number *\/$/;"	f
object_find_name	object.c	/^OBJECT *object_find_name(OBJECTNAME name){$/;"	f
object_flag_property	object.c	/^PROPERTY *object_flag_property(){$/;"	f
object_get_addr	object.c	/^void *object_get_addr(OBJECT *obj, \/**< object to look in *\/$/;"	f
object_get_complex	object.c	/^complex *object_get_complex(OBJECT *obj, PROPERTY *prop)$/;"	f
object_get_complex_by_name	object.c	/^complex *object_get_complex_by_name(OBJECT *obj, char *name)$/;"	f
object_get_complex_quick	object.c	/^complex *object_get_complex_quick(OBJECT *obj, PROPERTY *prop)$/;"	f
object_get_count	object.c	/^unsigned int object_get_count(){$/;"	f
object_get_double	object.c	/^double *object_get_double(OBJECT *obj, PROPERTY *prop)$/;"	f
object_get_double_by_name	object.c	/^double *object_get_double_by_name(OBJECT *obj, char *name)$/;"	f
object_get_double_quick	object.c	/^double *object_get_double_quick(OBJECT *obj, PROPERTY *prop)$/;"	f
object_get_enum	object.c	/^enumeration *object_get_enum(OBJECT *obj, PROPERTY *prop){$/;"	f
object_get_enum_by_name	object.c	/^enumeration *object_get_enum_by_name(OBJECT *obj, char *name){$/;"	f
object_get_first	object.c	/^OBJECT *object_get_first()$/;"	f
object_get_int16	object.c	/^int16 *object_get_int16(OBJECT *obj, PROPERTY *prop)$/;"	f
object_get_int16_by_name	object.c	/^int16 *object_get_int16_by_name(OBJECT *obj, char *name)$/;"	f
object_get_int32	object.c	/^int32 *object_get_int32(OBJECT *obj, PROPERTY *prop)$/;"	f
object_get_int32_by_name	object.c	/^int32 *object_get_int32_by_name(OBJECT *obj, char *name)$/;"	f
object_get_int64	object.c	/^int64 *object_get_int64(OBJECT *obj, PROPERTY *prop)$/;"	f
object_get_int64_by_name	object.c	/^int64 *object_get_int64_by_name(OBJECT *obj, char *name)$/;"	f
object_get_namespace	object.c	/^int object_get_namespace(OBJECT *obj, char *buffer, int size)$/;"	f
object_get_next	object.c	/^OBJECT *object_get_next(OBJECT *obj){ \/**< the object from which to start *\/$/;"	f
object_get_object	object.c	/^OBJECT *object_get_object(OBJECT *obj, PROPERTY *prop)$/;"	f
object_get_object_by_name	object.c	/^OBJECT *object_get_object_by_name(OBJECT *obj, char *name)$/;"	f
object_get_oflags	object.c	/^int object_get_oflags(KEYWORD **extflags){$/;"	f
object_get_property	object.c	/^PROPERTY *object_get_property(OBJECT *obj, \/**< a pointer to the object *\/$/;"	f
object_get_reference	object.c	/^OBJECT *object_get_reference(OBJECT *obj, char *name){$/;"	f
object_get_string	object.c	/^char *object_get_string(OBJECT *obj, PROPERTY *prop){$/;"	f
object_get_string_by_name	object.c	/^char *object_get_string_by_name(OBJECT *obj, char *name)$/;"	f
object_get_unit	object.c	/^char *object_get_unit(OBJECT *obj, char *name){$/;"	f
object_get_value_by_addr	object.c	/^int object_get_value_by_addr(OBJECT *obj, \/**< the object from which to get the data *\/$/;"	f
object_get_value_by_name	object.c	/^int object_get_value_by_name(OBJECT *obj, PROPERTYNAME name, char *value, int size)$/;"	f
object_id	load_xml_handle.h	/^	char object_id[64];$/;"	m	class:gldStack
object_id	object.h	316;"	d
object_index	load.c	/^static OBJECT **object_index = NULL;$/;"	v	file:
object_index_size	load.c	/^static unsigned int object_index_size = 65536;$/;"	v	file:
object_init	object.c	/^int object_init(OBJECT *obj){ \/**< the object to initialize *\/$/;"	f
object_isa	object.c	/^int object_isa(OBJECT *obj, \/**< the object to test *\/$/;"	f
object_isa	object.h	/^	int (*object_isa)(OBJECT *obj, char *type);$/;"	m	struct:s_callbacks
object_linked	load.c	/^static unsigned char *object_linked = NULL;$/;"	v	file:
object_locate_property	object.c	/^int object_locate_property(void *addr, OBJECT **pObj, PROPERTY **pProp)$/;"	f
object_name	load_xml_handle.h	/^	char object_name[64];$/;"	m	class:gldStack
object_name	object.c	/^char *object_name(OBJECT *obj){ \/**< a pointer to the object *\/$/;"	f
object_name_id	load.c	/^static int object_name_id(PARSER,char *classname, int64 *id)$/;"	f	file:
object_name_id_count	load.c	/^static int object_name_id_count(PARSER,char *classname, int64 *count)$/;"	f	file:
object_name_id_range	load.c	/^static int object_name_id_range(PARSER,char *classname, int64 *from, int64 *to)$/;"	f	file:
object_namespace	object.c	/^void object_namespace(char *buffer, int size)$/;"	f
object_open_namespace	object.c	/^int object_open_namespace(char *space)$/;"	f
object_parent	object.h	317;"	d
object_prop_in_class	object.c	/^PROPERTY *object_prop_in_class(OBJECT *obj, PROPERTY *prop){$/;"	f
object_properties	load.c	/^static int object_properties(PARSER, CLASS *oclass, OBJECT *obj)$/;"	f	file:
object_property_to_string	object.c	/^char *object_property_to_string(OBJECT *obj, char *name)$/;"	f
object_rank	object.h	318;"	d
object_remove_by_id	object.c	/^OBJECT *object_remove_by_id(OBJECTNUM id){$/;"	f
object_saveall	object.c	/^int object_saveall(FILE *fp) \/**< the stream to write to *\/$/;"	f
object_saveall_xml	object.c	/^int object_saveall_xml(FILE *fp){ \/**< the stream to write to *\/$/;"	f
object_saveall_xml_old	object.c	/^int object_saveall_xml_old(FILE *fp){ \/**< the stream to write to *\/$/;"	f
object_select_namespace	object.c	/^int object_select_namespace(char *space)$/;"	f
object_set_complex_by_name	object.c	/^int object_set_complex_by_name(OBJECT *obj, PROPERTYNAME name, complex value)$/;"	f
object_set_dependent	object.c	/^int object_set_dependent(OBJECT *obj, \/**< the object to set *\/$/;"	f
object_set_double_by_name	object.c	/^int object_set_double_by_name(OBJECT *obj, PROPERTYNAME name, double value)$/;"	f
object_set_int16_by_name	object.c	/^int object_set_int16_by_name(OBJECT *obj, PROPERTYNAME name, int16 value)$/;"	f
object_set_int32_by_name	object.c	/^int object_set_int32_by_name(OBJECT *obj, PROPERTYNAME name, int32 value)$/;"	f
object_set_int64_by_name	object.c	/^int object_set_int64_by_name(OBJECT *obj, PROPERTYNAME name, int64 value)$/;"	f
object_set_name	object.c	/^OBJECTNAME object_set_name(OBJECT *obj, OBJECTNAME name){$/;"	f
object_set_parent	object.c	/^int object_set_parent(OBJECT *obj, \/**< the object to set *\/$/;"	f
object_set_rank	object.c	/^int object_set_rank(OBJECT *obj, \/**< the object to set *\/$/;"	f
object_set_value_by_addr	object.c	/^int object_set_value_by_addr(OBJECT *obj, \/**< the object to alter *\/$/;"	f
object_set_value_by_name	object.c	/^int object_set_value_by_name(OBJECT *obj, \/**< the object to change *\/$/;"	f
object_size	object.h	315;"	d
object_sync	object.c	/^TIMESTAMP object_sync(OBJECT *obj, \/**< the object to synchronize *\/$/;"	f
object_tree_add	object.c	/^static OBJECTTREE *object_tree_add(OBJECT *obj, OBJECTNAME name){$/;"	f	file:
object_tree_delete	object.c	/^void object_tree_delete(OBJECT *obj, OBJECTNAME name)$/;"	f
object_tree_rebalance	object.c	/^int object_tree_rebalance(OBJECTTREE *tree) \/* AVL logic *\/$/;"	f
object_type	load_xml_handle.h	/^	char object_type[64];$/;"	m	class:gldStack
object_var	object.h	/^		OBJECT *(*object_var)(OBJECT *obj, PROPERTY *prop);$/;"	m	struct:s_callbacks::s_objvar_struct
object_var	object.h	/^		OBJECT *(*object_var)(OBJECT *obj, char *name);$/;"	m	struct:s_callbacks::s_objvar_name_struct
objectname	gui.h	/^	char objectname[64]; \/\/ ref object$/;"	m	struct:s_guientity
objects	object.h	/^		struct s_findlist *(*objects)(struct s_findlist *,...);$/;"	m	struct:s_callbacks::__anon34	typeref:struct:s_callbacks::__anon34::objects
objvar	object.h	/^	} objvar;$/;"	m	struct:s_callbacks	typeref:struct:s_callbacks::s_objvar_struct
objvarname	object.h	/^	} objvarname;$/;"	m	struct:s_callbacks	typeref:struct:s_callbacks::s_objvar_name_struct
oclass	class.h	/^	CLASS *oclass; \/**< class implementing the property *\/$/;"	m	struct:s_property_map
oclass	class.h	/^	CLASS *oclass; \/**< the class implementing the delegated type *\/$/;"	m	struct:s_delegatedtype
oclass	class.h	/^	CLASS *oclass;$/;"	m	struct:s_function_map
oclass	cmdarg.c	/^	CLASS *oclass;$/;"	m	struct:s_pntree	file:
oclass	debug.c	/^		CLASS *oclass; \/**< criteria for a class breakpoint *\/$/;"	m	union:s_breakpoint::__anon52	file:
oclass	load.h	/^	CLASS *oclass;$/;"	m	struct:s_unresolved
oclass	load_xml_handle.h	/^	CLASS *oclass;$/;"	m	class:gld_loadHndl
oclass	module.h	/^	CLASS *oclass;$/;"	m	struct:s_module_list
oclass	object.h	/^	CLASS *oclass; \/**< object class; determine structure of object data *\/$/;"	m	struct:s_object_list
off_end	loadshape.h	/^			double on_end, off_end;		\/**< ramp end times are computed internally to ease sync calcs *\/$/;"	m	struct:s_loadshape::__anon24::__anon29
off_ramp	loadshape.h	/^			double on_ramp, off_ramp;	\/**< the rate at which the high value comes on and off *\/$/;"	m	struct:s_loadshape::__anon24::__anon29
off_time	loadshape.h	/^			double on_time, off_time;	\/**< the hour of day when the high value comes on and goes off *\/$/;"	m	struct:s_loadshape::__anon24::__anon29
oflags	object.c	/^KEYWORD oflags[] = {$/;"	v
ok	stream.c	/^static int ok=1;$/;"	v	file:
on_end	loadshape.h	/^			double on_end, off_end;		\/**< ramp end times are computed internally to ease sync calcs *\/$/;"	m	struct:s_loadshape::__anon24::__anon29
on_ramp	loadshape.h	/^			double on_ramp, off_ramp;	\/**< the rate at which the high value comes on and off *\/$/;"	m	struct:s_loadshape::__anon24::__anon29
on_time	loadshape.h	/^			double on_time, off_time;	\/**< the hour of day when the high value comes on and goes off *\/$/;"	m	struct:s_loadshape::__anon24::__anon29
op	aggregate.h	/^	AGGREGATOR op; \/**< the aggregation operator (min, max, etc.) *\/$/;"	m	struct:s_aggregate
op	find.h	/^	COMPAREFUNC op;$/;"	m	struct:s_findpgm
op	load.c	/^	int op;$/;"	m	struct:s_rpn	file:
op_prec	load.c	/^static int op_prec[] = {0, 0, 0, 3, 2, 2, 2, 1, 1};$/;"	v	file:
operator !=	complex.h	/^	inline bool operator != (complex y)	{ return fmod(y.Arg()-Arg(),2*PI)!=0.0;};$/;"	f	class:complex
operator !=	complex.h	/^	inline bool operator != (double m)	{ return Mag()!=m; };$/;"	f	class:complex
operator *	complex.h	/^	inline complex operator * (complex y) \/**< complex multiply *\/$/;"	f	class:complex
operator *	complex.h	/^	inline complex operator * (double y) \/**< double multiply *\/$/;"	f	class:complex
operator *=	complex.h	/^	inline complex &operator *= (complex x)  \/**< multip[le by a complex number *\/$/;"	f	class:complex
operator *=	complex.h	/^	inline complex &operator *= (double x) \/**< multiply a double to real part *\/$/;"	f	class:complex
operator +	complex.h	/^	inline complex operator + (complex y) \/**< complex sum *\/$/;"	f	class:complex
operator +	complex.h	/^	inline complex operator + (double y) \/**< double sum *\/$/;"	f	class:complex
operator +=	complex.h	/^	inline complex &operator += (complex x) \/**< add a complex number *\/$/;"	f	class:complex
operator +=	complex.h	/^	inline complex &operator += (double x) \/**< add a double to the real part *\/$/;"	f	class:complex
operator -	complex.h	/^	inline complex operator - (complex y) \/**< complex subtract *\/$/;"	f	class:complex
operator -	complex.h	/^	inline complex operator - (double y) \/**< double subtract *\/$/;"	f	class:complex
operator -	complex.h	/^	inline complex operator - (void) \/**< change sign *\/$/;"	f	class:complex
operator -=	complex.h	/^	inline complex &operator -= (complex x)  \/**< subtract a complex number *\/$/;"	f	class:complex
operator -=	complex.h	/^	inline complex &operator -= (double x) \/**< subtract a double from the real part *\/$/;"	f	class:complex
operator /	complex.h	/^	inline complex operator \/ (complex y) \/**< complex divide *\/$/;"	f	class:complex
operator /	complex.h	/^	inline complex operator \/ (double y) \/**< double divide *\/$/;"	f	class:complex
operator /=	complex.h	/^	inline complex &operator \/= (complex y)  \/**< divide by a complex number *\/$/;"	f	class:complex
operator /=	complex.h	/^	inline complex &operator \/= (double x) \/**< divide into the real part *\/$/;"	f	class:complex
operator <	complex.h	/^	inline bool operator < (complex y)	{ return fmod(y.Arg()-Arg(),2*PI)<PI;};$/;"	f	class:complex
operator <	complex.h	/^	inline bool operator < (double m)	{ return Mag()<m; };$/;"	f	class:complex
operator <=	complex.h	/^	inline bool operator <= (complex y)	{ return fmod(y.Arg()-Arg(),2*PI)<=PI;};$/;"	f	class:complex
operator <=	complex.h	/^	inline bool operator <= (double m)	{ return Mag()<=m; };$/;"	f	class:complex
operator =	complex.h	/^	inline complex &operator = (complex x) \/**< complex assignment *\/$/;"	f	class:complex
operator =	complex.h	/^	inline complex &operator = (double x) \/**< double assignment *\/$/;"	f	class:complex
operator ==	complex.h	/^	inline bool operator == (complex y)	{ return fmod(y.Arg()-Arg(),2*PI)==0.0;};$/;"	f	class:complex
operator ==	complex.h	/^	inline bool operator == (double m)	{ return Mag()==m; };$/;"	f	class:complex
operator >	complex.h	/^	inline bool operator > (complex y)	{ return fmod(y.Arg()-Arg(),2*PI)>PI;};$/;"	f	class:complex
operator >	complex.h	/^	inline bool operator > (double m)	{ return Mag()>m; };$/;"	f	class:complex
operator >=	complex.h	/^	inline bool operator >= (complex y)	{ return fmod(y.Arg()-Arg(),2*PI)>=PI;};$/;"	f	class:complex
operator >=	complex.h	/^	inline bool operator >= (double m)	{ return Mag()>=m; };$/;"	f	class:complex
operator ^	complex.h	/^	inline complex operator ^ (complex y) \/**< complex power *\/$/;"	f	class:complex
operator ^	complex.h	/^	inline complex operator ^ (double y) \/**< double power *\/$/;"	f	class:complex
operator ^=	complex.h	/^	inline complex &operator ^= (complex x) \/**< raise to a complex power *\/$/;"	f	class:complex
operator ^=	complex.h	/^	inline complex &operator ^= (double x) \/**< raise to a real power *\/$/;"	f	class:complex
operator ~	complex.h	/^	inline complex operator ~ (void) \/**< complex conjugate *\/$/;"	f	class:complex
options	gui.h	/^	char options[1024]; \/\/ options for output$/;"	m	struct:s_guientity
ordinal	index.h	/^	LIST **ordinal;		\/**< the list of ordinals *\/$/;"	m	struct:s_index
original_test_end	test.c	/^STATUS original_test_end(int argc, char *argv[])$/;"	f
original_test_start	test.c	/^STATUS original_test_start(int argc, char *argv[])$/;"	f
out_svc	object.h	/^		out_svc; \/**< time at which object ceases operating *\/$/;"	m	struct:s_object_list
outfilename	load.c	/^static char *outfilename = NULL;$/;"	v	file:
outlinenum	load.c	/^static int outlinenum = 0;$/;"	v	file:
output	output.c	/^	FILE *output;$/;"	m	struct:s_redirection	file:
output_both_stdout	output.c	/^void output_both_stdout(){$/;"	f
output_cleanup	output.c	/^void output_cleanup(void)$/;"	f
output_debug	object.h	/^	int (*output_debug)(char *format, ...);$/;"	m	struct:s_callbacks
output_debug	output.c	/^int output_debug(char *format,...) \/**< \\bprintf style argument list *\/$/;"	f
output_error	kill.c	55;"	d	file:
output_error	object.h	/^	int (*output_error)(char *format, ...);$/;"	m	struct:s_callbacks
output_error	output.c	/^int output_error(char *format,...) \/**< \\bprintf style argument list *\/$/;"	f
output_error_raw	output.c	/^int output_error_raw(char *format,...) \/**< \\bprintf style argument list *\/$/;"	f
output_fatal	output.c	/^int output_fatal(char *format,...) \/**< \\bprintf style argument list *\/$/;"	f
output_get_time_context	output.c	/^char *output_get_time_context(void)$/;"	f
output_init	output.c	/^int output_init(int argc,char *argv[])$/;"	f
output_lock	output.c	/^static unsigned long output_lock = 0;$/;"	v	file:
output_message	object.h	/^	int (*output_message)(char *format, ...);$/;"	m	struct:s_callbacks
output_message	output.c	/^int output_message(char *format,...) \/**< \\bprintf style argument list *\/$/;"	f
output_notify_error	output.c	/^int output_notify_error(void (*notify)(void))$/;"	f
output_profile	output.c	/^int output_profile(char *format, ...) \/**< \/bprintf style argument list *\/$/;"	f
output_progress	output.c	/^int output_progress()$/;"	f
output_raw	output.c	/^int output_raw(char *format,...) \/**< \\bprintf style argument list *\/$/;"	f
output_redirect	output.c	/^FILE* output_redirect(char *name, char *path)$/;"	f
output_redirect_stream	output.c	/^FILE* output_redirect_stream(char *name, FILE *fp)$/;"	f
output_set_stderr	output.c	/^PRINTFUNCTION output_set_stderr(PRINTFUNCTION call) \/**< The \\b printf style function to call to send text to \\e stderr *\/$/;"	f
output_set_stdout	output.c	/^PRINTFUNCTION output_set_stdout(PRINTFUNCTION call) \/**< The \\b printf style function to call to send text to \\e stdout *\/$/;"	f
output_set_stream	output.c	/^FILE *output_set_stream(FILESTREAM fs, FILE *newfp){$/;"	f
output_set_time_context	output.c	/^void output_set_time_context(TIMESTAMP ts)$/;"	f
output_test	object.h	/^	int (*output_test)(char *format, ...);$/;"	m	struct:s_callbacks
output_test	output.c	/^int output_test(char *format,...) \/**< \\bprintf style argument list *\/$/;"	f
output_verbose	kill.c	56;"	d	file:
output_verbose	object.h	/^	int (*output_verbose)(char *format, ...);$/;"	m	struct:s_callbacks
output_verbose	output.c	/^int output_verbose(char *format,...) \/**< \\bprintf style argument list *\/$/;"	f
output_warning	object.h	/^	int (*output_warning)(char *format, ...);$/;"	m	struct:s_callbacks
output_warning	output.c	/^int output_warning(char *format,...) \/**< \\bprintf style argument list *\/$/;"	f
output_xsd	output.c	/^int output_xsd(char *spec)$/;"	f
output_xsl	output.c	/^int output_xsl(char *fname, int n_mods, char *p_mods[])$/;"	f
overflow	output.c	/^int overflow=CHECK;$/;"	v
p	random.c	/^} *p, map[] = {$/;"	v	typeref:struct:__anon55	file:
params	loadshape.h	/^	} params;	\/**< the machine parameters (depends on #type) *\/$/;"	m	struct:s_loadshape	typeref:union:s_loadshape::__anon24
parent	class.h	/^	CLASS *parent;			\/**< parent class from which properties should be inherited *\/$/;"	m	struct:s_class_list
parent	gui.h	/^	struct s_guientity *parent;$/;"	m	struct:s_guientity	typeref:struct:s_guientity::s_guientity
parent	object.h	/^	struct s_object_list *parent; \/**< object's parent; determines rank *\/$/;"	m	struct:s_object_list	typeref:struct:s_object_list::s_object_list
parent_name	object.h	/^    char *parent_name;$/;"	m	struct:string_linked_list
pareto	object.h	/^		double (*pareto)(double m, double a);$/;"	m	struct:s_callbacks::__anon35
part	aggregate.h	/^	AGGRPART part; \/**< the property part (complex only) *\/$/;"	m	struct:s_aggregate
pass	debug.c	/^		int64 pass; \/**< criteria for a pass number breakpoint *\/$/;"	m	union:s_breakpoint::__anon52	file:
pass	exec.c	/^static unsigned int pass;$/;"	v	file:
passconfig	class.h	/^	PASSCONFIG passconfig;$/;"	m	struct:s_class_list
passtype	exec.c	/^const PASSCONFIG passtype[] = {PC_PRETOPDOWN, PC_BOTTOMUP, PC_POSTTOPDOWN};$/;"	v
pathname	load.c	/^static int pathname(PARSER, char *path, int size)$/;"	f	file:
pathsep	find.c	1279;"	d	file:
pattern	load.c	/^static int pattern(PARSER, char *pattern, char *result, int size)$/;"	f	file:
pause_at_exit	main.c	/^void pause_at_exit(void) $/;"	f
pinfo	aggregate.h	/^	PROPERTY *pinfo; \/**< the property over which the aggregation is done *\/$/;"	m	struct:s_aggregate
plc	class.h	/^	FUNCTIONADDR plc;$/;"	m	struct:s_class_list
pmap	class.h	/^	PROPERTY *pmap;$/;"	m	struct:s_class_list
pntree	cmdarg.c	/^} pntree;$/;"	t	typeref:struct:s_pntree	file:
pointer	find.c	/^	COMPAREFUNC pointer, integer, real, string, int_16, int_32, int_64;	\/*	int_size to avoid #define int64 (platform.h) *\/$/;"	m	struct:__anon54	file:
pointer	find.c	/^	COMPAREFUNC pointer, integer, real, string;$/;"	m	struct:__anon53	file:
pointer	find.h	/^	void *pointer;$/;"	m	union:__anon16
pos	find.h	/^	FOUNDACTION pos, neg;$/;"	m	struct:s_findpgm
power	enduse.h	/^	complex power;				\/* constant power portion of load in kW *\/$/;"	m	struct:s_enduse
power	loadshape.h	/^			double power;		\/**< the power scaling factor of the shape (0 if energy is used) *\/$/;"	m	struct:s_loadshape::__anon24::__anon25
power_factor	enduse.h	/^	double power_factor;		\/* power factor *\/$/;"	m	struct:s_enduse
power_fraction	enduse.h	/^	double power_fraction;		\/* constant power fraction (pu load)*\/$/;"	m	struct:s_enduse
prec	unit.h	/^	int prec; \/** the precision of the unit definition *\/$/;"	m	struct:s_unit
precision	unit.c	/^static int precision = 10;			\/**, 10 digits max precision *\/$/;"	v	file:
prep_stream	output.c	/^static void prep_stream(){$/;"	f	file:
prev	list.h	/^	struct s_listitem *prev;$/;"	m	struct:s_listitem	typeref:struct:s_listitem::s_listitem
print_class	cmdarg.c	/^void print_class(CLASS *oclass){$/;"	f
print_class_d	cmdarg.c	/^void print_class_d(CLASS *oclass, int tabdepth){$/;"	f
print_modhelp_tree	cmdarg.c	/^void print_modhelp_tree(pntree *ctree){$/;"	f
printerr	output.c	/^static PRINTFUNCTION printstd=default_printstd, printerr=default_printerr;$/;"	v	file:
printstd	output.c	/^static PRINTFUNCTION printstd=default_printstd, printerr=default_printerr;$/;"	v	file:
process_macro	load.c	/^static int process_macro(char *line, int size, char *_filename, int linenum)$/;"	f	file:
processor_count	threadpool.c	/^int processor_count(void) { return get_nprocs(); }$/;"	f
processor_count	threadpool.c	/^int processor_count(void)$/;"	f
profile	output.c	/^	FILE *profile;$/;"	m	struct:s_redirection	file:
profiler	class.h	/^	} profiler;$/;"	m	struct:s_class_list	typeref:struct:s_class_list::__anon7
progress	output.c	/^	FILE *progress;$/;"	m	struct:s_redirection	file:
prop	debug.c	/^	PROPERTY *prop; \/**< the property being watched, if any *\/$/;"	m	struct:s_watchpoint	file:
prop	globals.h	/^	PROPERTY *prop;$/;"	m	struct:s_globalvar
prop	gui.h	/^	PROPERTY *prop;$/;"	m	struct:s_guientity
prop	load_xml_handle.h	/^	PROPERTY *prop;$/;"	m	class:gld_loadHndl
properties	object.h	/^	} properties;$/;"	m	struct:s_callbacks	typeref:struct:s_callbacks::__anon33
property_create	class.c	/^int property_create(PROPERTY *prop, void *addr)$/;"	f
property_malloc	class.c	/^PROPERTY *property_malloc(PROPERTYTYPE proptype, CLASS *oclass, char *name, void *addr, DELEGATEDTYPE *delegation)$/;"	f
property_ref	load.c	/^static int property_ref(PARSER, XFORMSOURCE *xstype, void **ref, OBJECT *from)$/;"	f	file:
property_size	class.c	/^unsigned long property_size(PROPERTY *prop)$/;"	f
property_size_by_type	class.c	/^unsigned long property_size_by_type(PROPERTYTYPE type)$/;"	f
property_specs	load.c	/^static int property_specs(PARSER, KEYWORD **keys)$/;"	f	file:
property_to_string	object.h	/^		int (*property_to_string)(PROPERTY *prop, void *addr, char *value, int size);$/;"	m	struct:s_callbacks::__anon40
property_type	class.c	/^} property_type[] = {$/;"	v	typeref:struct:s_property_specs	file:
property_type	load.c	/^static int property_type(PARSER, PROPERTYTYPE *ptype, KEYWORD **keys)$/;"	f	file:
propertyname	gui.h	/^	char propertyname[64]; \/\/ ref property$/;"	m	struct:s_guientity
propname	load_xml_handle.h	/^	char propname[256];$/;"	m	class:gld_loadHndl
pseudo	object.h	/^		double (*pseudo)(RANDOMTYPE type, unsigned int *state, ...);$/;"	m	struct:s_callbacks::__anon35
pseudorandom_value	random.c	/^double pseudorandom_value(RANDOMTYPE type, \/**< the type of distribution desired *\/$/;"	f
pthread_yield	threadpool.c	92;"	d	file:
ptype	class.h	/^	PROPERTYTYPE ptype; \/**< property type *\/$/;"	m	struct:s_property_map
ptype	load.h	/^	PROPERTYTYPE ptype;$/;"	m	struct:s_unresolved
pulsed	loadshape.h	/^		} pulsed;$/;"	m	union:s_loadshape::__anon24	typeref:struct:s_loadshape::__anon24::__anon26
pulseenergy	loadshape.h	/^			double pulseenergy;	\/**< the pulse energy *\/$/;"	m	struct:s_loadshape::__anon24::__anon27
pulsetype	loadshape.h	/^			MACHINEPULSETYPE pulsetype;	\/**< the fixed part of the pulse (time or power) *\/$/;"	m	struct:s_loadshape::__anon24::__anon26
pulsetype	loadshape.h	/^			MACHINEPULSETYPE pulsetype;	\/**< the fixed part of the pulse (time or power) *\/$/;"	m	struct:s_loadshape::__anon24::__anon27
pulsetype	loadshape.h	/^			MACHINEPULSETYPE pulsetype;	\/**< the fixed part of the pulse (time or power) *\/$/;"	m	struct:s_loadshape::__anon24::__anon28
pulsevalue	loadshape.h	/^			double pulsevalue;	\/**< the value of the fixed part of the pulse *\/$/;"	m	struct:s_loadshape::__anon24::__anon26
pulsevalue	loadshape.h	/^			double pulsevalue;	\/**< the value of the fixed part of the pulse *\/$/;"	m	struct:s_loadshape::__anon24::__anon27
pulsevalue	loadshape.h	/^			double pulsevalue;	\/**< the value of the fixed part of the pulse *\/$/;"	m	struct:s_loadshape::__anon24::__anon28
punit	aggregate.h	/^	UNIT *punit; \/**< the unit we want to output the property in *\/$/;"	m	struct:s_aggregate
q	loadshape.h	/^	double q;			\/**< the internal state of the machine *\/$/;"	m	struct:s_loadshape
q	stream.c	/^static unsigned int64 q;$/;"	v	file:
q_off	loadshape.h	/^			double q_on, q_off;	\/**< the queue thresholds (in units of 1 pulse) *\/$/;"	m	struct:s_loadshape::__anon24::__anon28
q_on	loadshape.h	/^			double q_on, q_off;	\/**< the queue thresholds (in units of 1 pulse) *\/$/;"	m	struct:s_loadshape::__anon24::__anon28
quadratic	object.h	/^		double (*quadratic)(double t, double x0, double y0, double x1, double y1, double x2, double y2);$/;"	m	struct:s_callbacks::__anon44
query	server.c	/^    char query[1024];$/;"	m	struct:s_http	file:
queued	loadshape.h	/^		} queued;$/;"	m	union:s_loadshape::__anon24	typeref:struct:s_loadshape::__anon24::__anon28
r	complex.h	/^	double r; \/**< the real part *\/$/;"	m	class:complex
r	complex.h	/^	double r; \/**< the real part *\/$/;"	m	struct:__anon13
r	loadshape.h	/^	double r;			\/**< the state rate *\/$/;"	m	struct:s_loadshape
random	object.h	/^	} random;$/;"	m	struct:s_callbacks	typeref:struct:s_callbacks::__anon35
random_apply	random.c	/^int random_apply(char *group_expression, \/**< the group definition; see find_objects() *\/$/;"	f
random_bernoulli	random.c	/^double random_bernoulli(double p) \/**< the probability of generating a 1 *\/$/;"	f
random_beta	random.c	/^double random_beta(double alpha, double beta) \/**< event parameters *\/$/;"	f
random_degenerate	random.c	/^double random_degenerate(double a)$/;"	f
random_exponential	random.c	/^double random_exponential(double lambda) \/**< the rate parameter lambda *\/$/;"	f
random_gamma	random.c	/^double random_gamma(double alpha, double beta)$/;"	f
random_init	random.c	/^int random_init(void)$/;"	f
random_lognormal	random.c	/^double random_lognormal(double gmu, \/**< the geometric mean *\/$/;"	f
random_nargs	random.c	/^int random_nargs(char *name)$/;"	f
random_normal	random.c	/^double random_normal(double m, \/**< the mean of the distribution *\/ $/;"	f
random_pareto	random.c	/^double random_pareto(double m, \/**< the minimum value *\/$/;"	f
random_rayleigh	random.c	/^double random_rayleigh(double sigma) \/**< mode parameter *\/$/;"	f
random_sampled	random.c	/^double random_sampled(unsigned n, \/**< the number of samples in the list *\/$/;"	f
random_test	random.c	/^int random_test(void)$/;"	f
random_triangle	random.c	/^double random_triangle(double a, double b)$/;"	f
random_type	random.c	/^RANDOMTYPE random_type(char *name) \/**< the name of the distribution *\/$/;"	f
random_uniform	random.c	/^double random_uniform(double a, \/**< the minimum number *\/ $/;"	f
random_value	random.c	/^double random_value(RANDOMTYPE type, \/**< the type of distribution desired *\/$/;"	f
random_weibull	random.c	/^double random_weibull(double lambda, \/**< scale parameter *\/$/;"	f
randunit	random.c	/^double randunit(void)$/;"	f
randunit_pos	random.c	/^double randunit_pos(void)$/;"	f
randwarn	random.c	/^int randwarn()$/;"	f
rank	debug.c	/^		int64 rank; \/**< criteria for a rank number breakpoint *\/$/;"	m	union:s_breakpoint::__anon52	file:
rank	object.h	/^	OBJECTRANK rank; \/**< object's rank *\/$/;"	m	struct:s_object_list
ranks	exec.c	/^static INDEX **ranks = NULL;$/;"	v	file:
rayleigh	object.h	/^		double (*rayleigh)(double a);$/;"	m	struct:s_callbacks::__anon35
re	loadshape.h	/^	double re[2];		\/**< the state rate stdevs (not used yet) *\/ $/;"	m	struct:s_loadshape
real	class.h	/^typedef double real;$/;"	t
real	class.h	/^typedef float real; $/;"	t
real	cmex.h	/^		double *real;$/;"	m	union:__anon10::__anon11
real	find.c	/^	COMPAREFUNC pointer, integer, real, string, int_16, int_32, int_64;	\/*	int_size to avoid #define int64 (platform.h) *\/$/;"	m	struct:__anon54	file:
real	find.c	/^	COMPAREFUNC pointer, integer, real, string;$/;"	m	struct:__anon53	file:
real	find.h	/^	double real;$/;"	m	union:__anon16
real_value	load.c	/^static int real_value(PARSER, double *value)$/;"	f	file:
realtime_now	realtime.c	/^time_t realtime_now(void)$/;"	f
realtime_run_schedule	realtime.c	/^STATUS realtime_run_schedule(void)$/;"	f
realtime_runtime	realtime.c	/^time_t realtime_runtime(void)$/;"	f
realtime_schedule_event	realtime.c	/^STATUS realtime_schedule_event(time_t at, STATUS (*callback)(void))$/;"	f
recalc	class.h	/^	FUNCTIONADDR recalc;$/;"	m	struct:s_class_list
recv_data	server.c	/^static size_t recv_data(SOCKET s,char *buffer, size_t len)$/;"	f	file:
redirect	output.c	/^} redirect;$/;"	v	typeref:struct:s_redirection	file:
ref	load.h	/^	void *ref;$/;"	m	struct:s_unresolved
register_class	object.h	/^	CLASS *(*register_class)(MODULE *,CLASSNAME,unsigned int,PASSCONFIG);$/;"	m	struct:s_callbacks
register_type	object.h	/^	DELEGATEDTYPE* (*register_type)(CLASS *oclass, char *type,int (*from_string)(void*,char*),int (*to_string)(void*,char*,int));$/;"	m	struct:s_callbacks
remove_objects	object.c	/^void remove_objects(){ $/;"	f
remove_objects	test_callbacks.h	/^	void (*remove_objects)(void);$/;"	m	struct:s_test_callbacks
replace_variables	load.c	/^int replace_variables(char *to,char *from,int len)$/;"	f
report	random.c	/^static int report(char *parameter, double actual, double expected, double error)$/;"	f	file:
reset_line	load.c	/^static void reset_line(FILE *fp, char *file)$/;"	f	file:
resolve_double	load.c	/^static int resolve_double(UNRESOLVED *item, char *context)$/;"	f	file:
resolve_list	load.c	/^static int resolve_list(UNRESOLVED *item)$/;"	f	file:
resolve_object	load.c	/^static int resolve_object(UNRESOLVED *item, char *filename)$/;"	f	file:
result	find.h	/^	char result[1]; \/* this will expand according to need *\/$/;"	m	struct:s_findlist
result_size	find.h	/^	unsigned int result_size;$/;"	m	struct:s_findlist
right	cmdarg.c	/^	struct s_pntree *left, *right;$/;"	m	struct:s_pntree	typeref:struct:s_pntree::	file:
rotate_tree_left	object.c	/^void rotate_tree_left(OBJECTTREE **tree){ \/* move one object from right to left *\/$/;"	f
rotate_tree_right	object.c	/^void rotate_tree_right(OBJECTTREE **tree){ \/* move one object from left to right *\/$/;"	f
row	gui.c	/^static int table=-1, row[MAX_TABLES], col[MAX_TABLES], span[MAX_TABLES];$/;"	v	file:
rpn_map	load.c	/^} rpn_map[] = {$/;"	v	typeref:struct:s_rpn_func
rpnfunc	load.c	/^static int rpnfunc(PARSER, int *val){$/;"	f	file:
run	threadpool.c	/^	void (*run)(int thread, void *item);$/;"	m	struct:threadpool	file:
run_aggregate	object.h	/^	double (*run_aggregate)(struct s_aggregate *aggregate);$/;"	m	struct:s_callbacks
s	loadshape.h	/^	MACHINESTATE s;		\/**< the current state of the machine (0 or 1) *\/$/;"	m	struct:s_loadshape
s	server.c	/^    SOCKET s;$/;"	m	struct:s_http	file:
s	stream.c	/^static unsigned short s;$/;"	v	file:
s	unit.c	/^static double s = 1.233270e4;		\/**< 1990$\/kgAu *\/$/;"	v	file:
s	unit.h	/^	double c,e,h,k,m,s,a,b; \/**< the unit parameters *\/$/;"	m	struct:s_unit
s_aggregate	aggregate.h	/^typedef struct s_aggregate {$/;"	s
s_breakpoint	debug.c	/^typedef struct s_breakpoint {$/;"	s	file:
s_callbacks	object.h	/^typedef struct s_callbacks {$/;"	s
s_class_list	class.h	/^struct s_class_list {$/;"	s
s_datetime	timestamp.h	/^typedef struct s_datetime {$/;"	s
s_delegatedtype	class.h	/^typedef struct s_delegatedtype$/;"	s
s_delegatedvalue	class.h	/^typedef struct s_delegatedvalue$/;"	s
s_enduse	enduse.h	/^typedef struct s_enduse {$/;"	s
s_eventlist	realtime.c	/^typedef struct s_eventlist {$/;"	s	file:
s_exception_handler	exception.h	/^typedef struct s_exception_handler {$/;"	s
s_findlist	find.h	/^typedef struct s_findlist {$/;"	s
s_findpgm	find.h	/^typedef struct s_findpgm {$/;"	s
s_function_map	class.h	/^typedef struct s_function_map {$/;"	s
s_globalvar	globals.h	/^typedef struct s_globalvar {$/;"	s
s_guientity	gui.h	/^typedef struct s_guientity {$/;"	s
s_http	server.c	/^typedef struct s_http {$/;"	s	file:
s_include_list	load.c	/^typedef struct s_include_list {$/;"	s	file:
s_index	index.h	/^typedef struct s_index {$/;"	s
s_keyword	class.h	/^typedef struct s_keyword {$/;"	s
s_list	list.h	/^typedef struct s_list {$/;"	s
s_listitem	list.h	/^typedef struct s_listitem {$/;"	s
s_loadshape	loadshape.h	/^struct s_loadshape {$/;"	s
s_locale	local.h	/^typedef struct s_locale {$/;"	s
s_module_list	module.h	/^struct s_module_list {$/;"	s
s_namespace	object.h	/^typedef struct s_namespace {$/;"	s
s_object_list	object.h	/^typedef struct s_object_list {$/;"	s
s_objecttree	object.c	/^typedef struct s_objecttree {$/;"	s	file:
s_objvar_name_struct	object.h	/^	struct s_objvar_name_struct {$/;"	s	struct:s_callbacks
s_objvar_struct	object.h	/^	struct s_objvar_struct {$/;"	s	struct:s_callbacks
s_pntree	cmdarg.c	/^typedef struct s_pntree{$/;"	s	file:
s_property_map	class.h	/^typedef struct s_property_map {$/;"	s
s_property_specs	class.c	/^static struct s_property_specs { \/**<	the property type conversion specifications.$/;"	s	file:
s_redirection	output.c	/^static struct s_redirection {$/;"	s	file:
s_rpn	load.c	/^struct s_rpn {$/;"	s	file:
s_rpn_func	load.c	/^struct s_rpn_func {$/;"	s	file:
s_schedule	schedule.h	/^struct s_schedule {$/;"	s
s_schedulexform	schedule.h	/^typedef struct s_schedulexform {$/;"	s
s_test_callbacks	test_callbacks.h	/^typedef struct s_test_callbacks{$/;"	s
s_unit	unit.h	/^typedef struct s_unit {$/;"	s
s_unitscalar	unit.c	/^struct s_unitscalar {$/;"	s	file:
s_unresolved	load.h	/^typedef struct s_unresolved {$/;"	s
s_unresolved_func	load.h	/^typedef struct s_unresolved_func {$/;"	s
s_varmap	globals.c	/^static struct s_varmap {$/;"	s	file:
s_watchpoint	debug.c	/^typedef struct s_watchpoint {$/;"	s	file:
sample_from_diversity	loadshape.c	/^int sample_from_diversity(double *param, char *value)$/;"	f
sampled	object.h	/^		double (*sampled)(unsigned int n, double *x);$/;"	m	struct:s_callbacks::__anon35
saveall	save.c	/^int saveall(char *filename)$/;"	f
savetxt	save.c	/^int savetxt(char *filename,FILE *fp)$/;"	f
savexml	save.c	/^int savexml(char *filename,FILE *fp)$/;"	f
savexml_strict	save.c	/^int savexml_strict(char *filename,FILE *fp)$/;"	f
scalar	loadshape.h	/^			double scalar;		\/**< the number of pulses over the shape *\/$/;"	m	struct:s_loadshape::__anon24::__anon26
scalar	loadshape.h	/^			double scalar;		\/**< the number of pulses over the shape *\/$/;"	m	struct:s_loadshape::__anon24::__anon27
scalar	loadshape.h	/^			double scalar;		\/**< the number of pulses over the shape *\/$/;"	m	struct:s_loadshape::__anon24::__anon28
scalar	unit.c	/^	int scalar;$/;"	m	struct:s_unitscalar	file:
scalar_list	unit.c	/^UNITSCALAR *scalar_list = NULL;$/;"	v
scale	aggregate.h	/^	double scale; \/**< the scalar to convert from the old units to the desired units *\/$/;"	m	struct:s_aggregate
scale	schedule.h	/^	double scale;$/;"	m	struct:s_schedulexform
scan	load.c	/^static int scan(PARSER, char *format, char *result, int size)$/;"	f	file:
schedule	load.c	/^static int schedule(PARSER)$/;"	f	file:
schedule	loadshape.h	/^	SCHEDULE *schedule;	\/**< the schedule driving this machine *\/$/;"	m	struct:s_loadshape
schedule	object.h	/^	} schedule;$/;"	m	struct:s_callbacks	typeref:struct:s_callbacks::__anon41
schedule_add	schedule.c	/^void schedule_add(SCHEDULE *sch)$/;"	f
schedule_add_xform	schedule.c	/^int schedule_add_xform(XFORMSOURCE stype,	\/* specifies the type of source *\/$/;"	f
schedule_compile	schedule.c	/^int schedule_compile(SCHEDULE *sch)$/;"	f
schedule_compile_block	schedule.c	/^int schedule_compile_block(SCHEDULE *sch, char *blockname, char *blockdef)$/;"	f
schedule_create	schedule.c	/^SCHEDULE *schedule_create(char *name,		\/**< the name of the schedule *\/$/;"	f
schedule_dtnext	schedule.c	/^int32 schedule_dtnext(SCHEDULE *sch,			\/**< the schedule to read *\/$/;"	f
schedule_dump	schedule.c	/^void schedule_dump(SCHEDULE *sch, char *file)$/;"	f
schedule_duration	schedule.c	/^int32 schedule_duration(SCHEDULE *sch,			\/**< the schedule to read *\/$/;"	f
schedule_find_byname	schedule.c	/^SCHEDULE *schedule_find_byname(char *name) \/**< the name of the schedule *\/$/;"	f
schedule_getnext	schedule.c	/^SCHEDULE *schedule_getnext(SCHEDULE *sch) \/**< the schedule (or NULL to get first) *\/$/;"	f
schedule_index	schedule.c	/^SCHEDULEINDEX schedule_index(SCHEDULE *sch, TIMESTAMP ts)$/;"	f
schedule_list	schedule.c	/^static SCHEDULE *schedule_list = NULL;$/;"	v	file:
schedule_matcher	schedule.c	/^int schedule_matcher(char *pattern, unsigned char *table, int max, int base)$/;"	f
schedule_new	schedule.c	/^SCHEDULE *schedule_new(void)$/;"	f
schedule_normalize	schedule.c	/^int schedule_normalize(SCHEDULE *sch,	\/**< the schedule to normalize *\/$/;"	f
schedule_ref	load.c	/^static int schedule_ref(PARSER, SCHEDULE **sch)$/;"	f	file:
schedule_skew	object.h	/^	TIMESTAMP schedule_skew;$/;"	m	struct:s_object_list
schedule_string_to_weekday	loadshape.c	/^unsigned char schedule_string_to_weekday(char *days)$/;"	f
schedule_sync	schedule.c	/^TIMESTAMP schedule_sync(SCHEDULE *sch, \/**< the schedule that is to be synchronized *\/$/;"	f
schedule_syncall	schedule.c	/^TIMESTAMP schedule_syncall(TIMESTAMP t1) \/**< the time to which the schedule is synchronized *\/$/;"	f
schedule_test	schedule.c	/^int schedule_test(void)$/;"	f
schedule_validate	schedule.c	/^int schedule_validate(SCHEDULE *sch, int flags)$/;"	f
schedule_value	schedule.c	/^double schedule_value(SCHEDULE *sch,		\/**< the schedule to read *\/$/;"	f
schedule_weekday_to_string	loadshape.c	/^char *schedule_weekday_to_string(unsigned char days)$/;"	f
schedule_weight	schedule.c	/^double schedule_weight(SCHEDULE *sch,			\/**< the schedule to read *\/$/;"	f
schedule_xformlist	schedule.c	/^static SCHEDULEXFORM *schedule_xformlist=NULL;$/;"	v	file:
scheduled	loadshape.h	/^		} scheduled;$/;"	m	union:s_loadshape::__anon24	typeref:struct:s_loadshape::__anon24::__anon29
scheduletransform_getnext	schedule.c	/^SCHEDULEXFORM *scheduletransform_getnext(SCHEDULEXFORM *xform)$/;"	f
scheduletransform_syncall	schedule.c	/^TIMESTAMP scheduletransform_syncall(TIMESTAMP t1, XFORMSOURCE restrict)$/;"	f
second	timestamp.h	/^	unsigned short second; \/**< second (0-59) *\/$/;"	m	struct:s_datetime
send_data	server.c	/^static size_t send_data(SOCKET s, char *buffer, size_t len)$/;"	f	file:
server_routine	server.c	/^static void *server_routine(void *arg)$/;"	f	file:
server_startup	server.c	/^STATUS server_startup(int argc, char *argv[])$/;"	f
set	class.h	/^typedef unsigned int64 set; \/* sets (each of up to 64 values may be defined) *\/$/;"	t
set_callback	gridlabd.h	316;"	d
set_dependent	object.h	/^	int (*set_dependent)(OBJECT*,OBJECT*);$/;"	m	struct:s_callbacks
set_flags	load.c	/^int set_flags(OBJECT *obj, char1024 propval)$/;"	f
set_global_run_realtime	globals.c	/^void set_global_run_realtime(int set)$/;"	f
set_header_value	object.c	/^static int set_header_value(OBJECT *obj, char *name, char *value)$/;"	f	file:
set_object_data	cmex.c	/^static void set_object_data(const mxArray *data)$/;"	f	file:
set_parent	object.h	/^	int (*set_parent)(OBJECT*,OBJECT*);$/;"	m	struct:s_callbacks
set_rank	object.c	/^static int set_rank(OBJECT *obj, OBJECTRANK rank, OBJECT *first)$/;"	f	file:
set_rank	object.h	/^	int (*set_rank)(OBJECT*,unsigned int);$/;"	m	struct:s_callbacks
set_tabs	cmdarg.c	/^void set_tabs(char *tabs, int tabdepth){$/;"	f
set_tzspec	timestamp.c	/^void set_tzspec(int year, char *tzname, SPEC *pStart, SPEC *pEnd){$/;"	f
set_value_by_addr	object.h	/^		int (*set_value_by_addr)(OBJECT *, void*, char*,PROPERTY*);$/;"	m	struct:s_callbacks::__anon33
set_value_by_name	object.h	/^		int (*set_value_by_name)(OBJECT *, char*, char*);$/;"	m	struct:s_callbacks::__anon33
set_value_by_type	object.h	/^		int (*set_value_by_type)(PROPERTYTYPE,void *data,char *);$/;"	m	struct:s_callbacks::__anon33
setup_class	load.c	/^static char *setup_class(CLASS *oclass)$/;"	f	file:
setup_ranks	exec.c	/^static STATUS setup_ranks(void)$/;"	f	file:
setup_test_ranks	test_callbacks.h	/^	STATUS (*setup_test_ranks)(void);$/;"	m	struct:s_test_callbacks
setvar	module.h	/^	int (*setvar)(char *varname,char *value);$/;"	m	struct:s_module_list
setvar	object.h	/^		STATUS (*setvar)(char *def,...);$/;"	m	struct:s_callbacks::__anon38
shape	enduse.h	/^	loadshape *shape;$/;"	m	struct:s_enduse
show_progress	exec.c	/^static STATUS show_progress(void)$/;"	f	file:
shutdown_now	server.c	/^static void shutdown_now(void)$/;"	f	file:
shutdown_server	server.c	/^static int shutdown_server = 0; \/* flag to stop accepting incoming messages *\/$/;"	v	file:
sigint_caught	debug.c	/^static int sigint_caught = 0; \/**< flag indicating that \\p SIGINT has been caught *\/$/;"	v	file:
siglist	debug.c	/^int siglist[] = {SIGABRT, SIGINT, SIGFPE, SIGSEGV, SIGTERM};$/;"	v
signal_completion	threadpool.c	139;"	d	file:
signal_completion	threadpool.c	152;"	d	file:
signal_completion	threadpool.c	82;"	d	file:
signal_exec	threadpool.c	136;"	d	file:
signal_exec	threadpool.c	150;"	d	file:
signal_exec	threadpool.c	81;"	d	file:
sigterm_caught	debug.c	/^static int sigterm_caught = 0; \/**< flag indicating that \\p SIGTERM has been caught *\/$/;"	v	file:
simtime	exec.c	/^char *simtime(void)$/;"	f
since	schedule.h	/^	TIMESTAMP since;$/;"	m	struct:s_schedule
single	object.h	/^		OBJECT *(*single)(CLASS*);$/;"	m	struct:s_callbacks::__anon31
size	class.c	/^	unsigned int size; \/**< the size of 1 instance *\/$/;"	m	struct:s_property_specs	file:
size	class.h	/^	unsigned int size;$/;"	m	struct:s_class_list
size	class.h	/^	unsigned long size; \/**< property array size *\/$/;"	m	struct:s_property_map
size	gui.h	/^	int size; \/\/ size spec$/;"	m	struct:s_guientity
size	list.h	/^	unsigned int size;$/;"	m	struct:s_list
snprintf	find.c	14;"	d	file:
snprintf	globals.c	105;"	d	file:
snprintf	load.c	166;"	d	file:
snprintf	module.c	31;"	d	file:
sockfd	server.c	/^SOCKET sockfd = (SOCKET)0;$/;"	v
sort	random.c	/^static void sort(double sample[], unsigned int count)$/;"	f	file:
source	gui.h	/^	char source[1024]; \/\/ source file for data (output only)$/;"	m	struct:s_guientity
source	schedule.h	/^	double *source;$/;"	m	struct:s_schedulexform
source_addr	schedule.h	/^	void *source_addr;$/;"	m	struct:s_schedulexform
source_code	load.c	/^static int source_code(PARSER, char *code, int size)$/;"	f	file:
source_schedule	schedule.h	/^	SCHEDULE *source_schedule;$/;"	m	struct:s_schedulexform
source_type	schedule.h	/^	XFORMSOURCE source_type;$/;"	m	struct:s_schedulexform
space	object.h	/^	NAMESPACE *space; \/**< namespace of object *\/$/;"	m	struct:s_object_list
span	gui.c	/^static int table=-1, row[MAX_TABLES], col[MAX_TABLES], span[MAX_TABLES];$/;"	v	file:
span	gui.h	/^	int span; \/\/ col span$/;"	m	struct:s_guientity
srcref	gui.h	/^	char srcref[1024]; \/\/ reference to source file location$/;"	m	struct:s_guientity
ss_do_object_sync	exec.c	/^static void ss_do_object_sync(int thread, void *item)$/;"	f	file:
ss_do_object_sync_list	exec.c	/^static void *ss_do_object_sync_list(void *threadarg)$/;"	f	file:
stack	local.c	/^static LOCALE *stack=NULL;$/;"	v	file:
stack_ptr	load_xml_handle.h	/^	gldStack *stack_ptr;$/;"	m	class:gld_loadHndl
stack_state	load_xml_handle.h	/^	gld_state	stack_state;$/;"	m	class:gld_loadHndl
start	exec.c	/^clock_t start, end;$/;"	v
start_ts	load.c	/^static char start_ts[64];$/;"	v	file:
startspan	gui.c	/^static void startspan()$/;"	f	file:
status	exec.h	/^	STATUS status; \/**< the current status *\/$/;"	m	struct:sync_data
status	server.c	/^    char *status;$/;"	m	struct:s_http	file:
stdev	random.c	/^static double stdev(double sample[], unsigned int count)$/;"	f	file:
step_to	exec.h	/^	TIMESTAMP step_to; \/**< time to advance to *\/$/;"	m	struct:sync_data
stop_now	debug.c	/^int stop_now = 0; \/**< flag indicating that main loop needs to be step (and debugger activated if allowed) *\/$/;"	v
stop_ts	load.c	/^static char stop_ts[64];$/;"	v	file:
strdatetime	object.h	/^		int (*strdatetime)(DATETIME *t, char *buffer, int size);$/;"	m	struct:s_callbacks::__anon36
strdatetime	timestamp.c	/^int strdatetime(DATETIME *t, char *buffer, int size){$/;"	f
stream_compress	stream.c	/^size_t stream_compress(FILE *fp, char *buf, size_t len)$/;"	f
stream_context	stream.c	/^char *stream_context()$/;"	f
stream_decompress	stream.c	/^size_t stream_decompress(FILE *fp, const char *buf, const size_t len)$/;"	f
stream_error	stream.c	/^int stream_error(char *format, ...)$/;"	f
stream_in	class.c	/^	int (*stream_in)(FILE*,void*,PROPERTY*); \/**< the function to read data from a stream *\/$/;"	m	struct:s_property_specs	file:
stream_in	stream.c	/^int64 stream_in(FILE *fp, int flags)$/;"	f
stream_in_class	stream.c	/^int stream_in_class(FILE *fp)$/;"	f
stream_in_double	stream.c	/^int stream_in_double(FILE *fp,void *ptr,PROPERTY *prop)$/;"	f
stream_in_global	stream.c	/^int64 stream_in_global(FILE *fp)$/;"	f
stream_in_module	stream.c	/^int64 stream_in_module(FILE *fp)$/;"	f
stream_in_object	stream.c	/^int64 stream_in_object(fp)$/;"	f
stream_in_property	stream.c	/^int64 stream_in_property(FILE *fp, PROPERTY *p)$/;"	f
stream_in_schedule	stream.c	/^int64 stream_in_schedule(fp)$/;"	f
stream_in_transform	stream.c	/^int64 stream_in_transform(fp)$/;"	f
stream_out	class.c	/^	int (*stream_out)(FILE*,void*,PROPERTY*); \/**< the function to write data to a stream *\/$/;"	m	struct:s_property_specs	file:
stream_out	stream.c	/^int64 stream_out(FILE *fp, int flags)$/;"	f
stream_out_class	stream.c	/^int64 stream_out_class(FILE *fp, CLASS *oclass)$/;"	f
stream_out_double	stream.c	/^int stream_out_double(FILE *fp,void *ptr,PROPERTY *prop)$/;"	f
stream_out_global	stream.c	/^int64 stream_out_global(FILE *fp, GLOBALVAR *v)$/;"	f
stream_out_keyword	stream.c	/^int64 stream_out_keyword(FILE *fp, KEYWORD *k)$/;"	f
stream_out_module	stream.c	/^int64 stream_out_module(FILE *fp, MODULE *m)$/;"	f
stream_out_object	stream.c	/^int64 stream_out_object(FILE *fp, OBJECT *obj)$/;"	f
stream_out_property	stream.c	/^int64 stream_out_property(FILE *fp, PROPERTY *p)$/;"	f
stream_out_schedule	stream.c	/^int64 stream_out_schedule(FILE *fp, SCHEDULE *sch)$/;"	f
stream_out_transform	stream.c	/^int64 stream_out_transform(FILE *fp, SCHEDULEXFORM *xform)$/;"	f
stream_out_unit	stream.c	/^int64 stream_out_unit(FILE *fp, UNIT *u)$/;"	f
stream_prep	output.c	/^static int stream_prep = 0;$/;"	v	file:
stream_warning	stream.c	/^int stream_warning(char *format, ...)$/;"	f
stricmp	platform.h	45;"	d
string	find.c	/^	COMPAREFUNC pointer, integer, real, string, int_16, int_32, int_64;	\/*	int_size to avoid #define int64 (platform.h) *\/$/;"	m	struct:__anon54	file:
string	find.c	/^	COMPAREFUNC pointer, integer, real, string;$/;"	m	struct:__anon53	file:
string	find.h	/^	char string[256];$/;"	m	union:__anon16
string_linked_list	object.h	/^typedef struct string_linked_list {$/;"	s
string_to_data	class.c	/^	int (*string_to_data)(char *,void*,PROPERTY*); \/**< the function to convert from a string to data *\/$/;"	m	struct:s_property_specs	file:
string_to_property	object.h	/^		int (*string_to_property)(PROPERTY *prop, void *addr, char *value);$/;"	m	struct:s_callbacks::__anon40
string_var	object.h	/^		char *(*string_var)(OBJECT *obj, PROPERTY *prop);$/;"	m	struct:s_callbacks::s_objvar_struct
string_var	object.h	/^		char *(*string_var)(OBJECT *obj, char *name);$/;"	m	struct:s_callbacks::s_objvar_name_struct
strip_right_white	load.c	/^static char *strip_right_white(char *b){$/;"	f	file:
strlwr	platform.h	40;"	d
strnicmp	platform.h	46;"	d
strsignal	debug.c	/^char *strsignal(int sig)$/;"	f
subload	module.h	/^	MODULE *(*subload)(char *, MODULE **, CLASS **, int, char **);$/;"	m	struct:s_module_list
sum	schedule.h	/^	double sum[MAXBLOCKS];				\/**< the sum of values for each block -- used to normalize *\/$/;"	m	struct:s_schedule
suppress	load.c	/^static int suppress = 0;$/;"	v	file:
sync	class.h	/^	FUNCTIONADDR sync;$/;"	m	struct:s_class_list
sync	object.h	/^		TIMESTAMP (*sync)(struct s_enduse *e, PASSCONFIG pass, TIMESTAMP t1);$/;"	m	struct:s_callbacks::__anon43
sync	threadpool.c	/^	sync_t sync;$/;"	m	struct:threadpool	file:
sync_all	test_callbacks.h	/^	STATUS (*sync_all)(PASSCONFIG pass);$/;"	m	struct:s_test_callbacks
sync_analog	loadshape.c	/^static void sync_analog(loadshape *ls, double dt)$/;"	f	file:
sync_data	exec.h	/^struct sync_data {$/;"	s
sync_done	threadpool.c	/^static __inline void sync_done(struct threadpool *tp)$/;"	f	file:
sync_done	threadpool.c	145;"	d	file:
sync_init	threadpool.c	/^static __inline void sync_init(struct threadpool *tp)$/;"	f	file:
sync_init	threadpool.c	144;"	d	file:
sync_modulated	loadshape.c	/^static void sync_modulated(loadshape *ls, double dt)$/;"	f	file:
sync_pulsed	loadshape.c	/^static void sync_pulsed(loadshape *ls, double dt)$/;"	f	file:
sync_queued	loadshape.c	/^static void sync_queued(loadshape *ls, double dt)$/;"	f	file:
sync_scheduled	loadshape.c	/^static void sync_scheduled(loadshape *ls, TIMESTAMP t1)$/;"	f	file:
sync_t	threadpool.c	/^typedef char sync_t;$/;"	t	file:
sync_t	threadpool.c	/^} sync_t;$/;"	t	typeref:struct:__anon58	file:
sync_t	threadpool.c	/^} sync_t;$/;"	t	typeref:struct:__anon59	file:
syncall_internals	exec.c	/^TIMESTAMP syncall_internals(TIMESTAMP t1)$/;"	f
syntax_error	find.c	/^void syntax_error(char *p)$/;"	f
syntax_error	load.c	/^static void syntax_error(char *p)$/;"	f	file:
t	stream.c	/^static unsigned char b,t;$/;"	v	file:
t0	loadshape.h	/^	TIMESTAMP t0;	\/**< time of last update (in seconds since epoch) *\/$/;"	m	struct:s_loadshape
t2	loadshape.h	/^	TIMESTAMP t2;	\/**< time of next update (in seconds since epoch) *\/$/;"	m	struct:s_loadshape
t_last	enduse.h	/^	TIMESTAMP t_last;			\/* last time of update *\/$/;"	m	struct:s_enduse
t_setup_ranks	exec.c	/^STATUS t_setup_ranks(void){$/;"	f
t_sync_all	exec.c	/^STATUS t_sync_all(PASSCONFIG pass)$/;"	f
table	gui.c	/^static int table=-1, row[MAX_TABLES], col[MAX_TABLES], span[MAX_TABLES];$/;"	v	file:
targ	load.h	/^	double *targ;$/;"	m	struct:s_unresolved_func
target	find.h	/^	unsigned short target; \/* offset from start of object header *\/$/;"	m	struct:s_findpgm
target	schedule.h	/^	double *target;$/;"	m	struct:s_schedulexform
target_obj	schedule.h	/^	struct s_object_list *target_obj;$/;"	m	struct:s_schedulexform	typeref:struct:s_schedulexform::s_object_list
target_prop	schedule.h	/^	struct s_property_map *target_prop;$/;"	m	struct:s_schedulexform	typeref:struct:s_schedulexform::s_property_map
test	module.h	/^	void (*test)(int argc, char *argv[]);	$/;"	m	struct:s_module_list
test_end	test.c	/^STATUS test_end(int argc, char *argv[])$/;"	f
test_helper	test_framework.h	/^class test_helper: public CppUnit::TestFixture$/;"	c
test_init	test.c	/^STATUS test_init(void)$/;"	f
test_start	test.c	/^STATUS test_start(int argc, char *argv[])$/;"	f
thread	exec.c	/^    int thread;$/;"	m	struct:arg_data	file:
thread_count	threadpool.c	/^	int thread_count, thread_index, thread_die, wait_count;$/;"	m	struct:threadpool	file:
thread_data	exec.c	/^static struct thread_data *thread_data = NULL;$/;"	v	typeref:struct:thread_data	file:
thread_data	exec.h	/^struct thread_data {$/;"	s
thread_die	threadpool.c	/^	int thread_count, thread_index, thread_die, wait_count;$/;"	m	struct:threadpool	file:
thread_index	threadpool.c	/^	int thread_count, thread_index, thread_die, wait_count;$/;"	m	struct:threadpool	file:
thread_proc	threadpool.c	/^static void *thread_proc(void *arg)$/;"	f	file:
threadpool	threadpool.c	/^struct threadpool {$/;"	s	file:
threadpool_t	threadpool.h	/^typedef const void * threadpool_t;$/;"	t
throw_exception	exception.c	/^void throw_exception(char *format, \/**< the format string *\/$/;"	f
throw_exception	object.h	/^		void (*throw_exception)(char *msg, ...);$/;"	m	struct:s_callbacks::__anon37
time	cmex.h	/^	double time;$/;"	m	struct:__anon8
time	object.h	/^	} time;$/;"	m	struct:s_callbacks	typeref:struct:s_callbacks::__anon36
time_context	output.c	/^static char time_context[256]="INIT";$/;"	v	file:
time_value	find.c	/^static int time_value(PARSER, TIMESTAMP *t)$/;"	f	file:
time_value	load.c	/^\/*static*\/ int time_value(PARSER, TIMESTAMP *t)$/;"	f
time_value_datetime	find.c	/^static int time_value_datetime(PARSER, TIMESTAMP *t)$/;"	f	file:
time_value_datetime	load.c	/^int time_value_datetime(PARSER, TIMESTAMP *t)$/;"	f
time_value_datetimezone	load.c	/^static int time_value_datetimezone(PARSER, TIMESTAMP *t)$/;"	f	file:
time_value_days	find.c	/^static int time_value_days(PARSER, TIMESTAMP *t)$/;"	f	file:
time_value_days	load.c	/^static int time_value_days(PARSER, TIMESTAMP *t)$/;"	f	file:
time_value_hours	find.c	/^static int time_value_hours(PARSER, TIMESTAMP *t)$/;"	f	file:
time_value_hours	load.c	/^static int time_value_hours(PARSER, TIMESTAMP *t)$/;"	f	file:
time_value_minutes	find.c	/^static int time_value_minutes(PARSER, TIMESTAMP *t)$/;"	f	file:
time_value_minutes	load.c	/^static int time_value_minutes(PARSER, TIMESTAMP *t)$/;"	f	file:
time_value_seconds	find.c	/^static int time_value_seconds(PARSER, TIMESTAMP *t)$/;"	f	file:
time_value_seconds	load.c	/^static int time_value_seconds(PARSER, TIMESTAMP *t)$/;"	f	file:
timestamp	timestamp.h	/^	TIMESTAMP timestamp; \/**< GMT timestamp *\/$/;"	m	struct:s_datetime
timestamp_current_timezone	timestamp.c	/^char *timestamp_current_timezone(void){$/;"	f
timestamp_set_tz	timestamp.c	/^char *timestamp_set_tz(char *tz_name){$/;"	f
timestamp_test	timestamp.c	/^int timestamp_test(void)$/;"	f
timestamp_to_days	object.h	/^		double (*timestamp_to_days)(TIMESTAMP t);$/;"	m	struct:s_callbacks::__anon36
timestamp_to_days	timestamp.c	/^double timestamp_to_days(TIMESTAMP t)$/;"	f
timestamp_to_hours	object.h	/^		double (*timestamp_to_hours)(TIMESTAMP t);$/;"	m	struct:s_callbacks::__anon36
timestamp_to_hours	timestamp.c	/^double timestamp_to_hours(TIMESTAMP t)$/;"	f
timestamp_to_minutes	object.h	/^		double (*timestamp_to_minutes)(TIMESTAMP t);$/;"	m	struct:s_callbacks::__anon36
timestamp_to_minutes	timestamp.c	/^double timestamp_to_minutes(TIMESTAMP t)$/;"	f
timestamp_to_seconds	object.h	/^		double (*timestamp_to_seconds)(TIMESTAMP t);$/;"	m	struct:s_callbacks::__anon36
timestamp_to_seconds	timestamp.c	/^double timestamp_to_seconds(TIMESTAMP t)$/;"	f
timestamp_year	timestamp.c	/^int timestamp_year(TIMESTAMP ts, TIMESTAMP *remainder){$/;"	f
to_string	class.h	/^	int (*to_string)(void *addr, char *value, int size); \/**< the function that converts from the data to a string *\/$/;"	m	struct:s_delegatedtype
token	find.c	/^static int token(PARSER, char *result, int size)$/;"	f	file:
top	object.c	/^static OBJECTTREE *top=NULL;$/;"	v	file:
total	enduse.h	/^	complex total;				\/* total power in kW *\/$/;"	m	struct:s_enduse
tp_affinity	object.h	/^	int tp_affinity; \/**< threadpool processor affinity *\/$/;"	m	struct:s_object_list
tp_alloc	threadpool.c	/^threadpool_t tp_alloc(int *count, void (*run)(int thread, void *item))$/;"	f
tp_exec	threadpool.c	/^void tp_exec(threadpool_t pool, LIST *list)$/;"	f
tp_release	threadpool.c	/^void tp_release(threadpool_t pool)$/;"	f
transform_source	load.c	/^static int transform_source(PARSER, XFORMSOURCE *xstype, void **source, OBJECT *from)$/;"	f	file:
tree_get_height	object.c	/^int tree_get_height(OBJECTTREE *tree){$/;"	f
triangle	object.h	/^		double (*triangle)(double a, double b);$/;"	m	struct:s_callbacks::__anon35
triplet	class.h	/^typedef double triplet[3];$/;"	t
triplex	class.h	/^typedef complex triplex[3];$/;"	t
true	class.h	47;"	d
ts	debug.c	/^		TIMESTAMP ts; \/**< criteria for a timestamp breakpoint *\/$/;"	m	union:s_breakpoint::__anon52	file:
tszero	timestamp.c	/^static TIMESTAMP tszero[1000] = {-1}; \/* zero timestamp offset for each year *\/$/;"	v	file:
type	class.h	/^	DELEGATEDTYPE *type; \/**< the delegation specification to use *\/$/;"	m	struct:s_delegatedvalue
type	class.h	/^	char32 type; \/**< the name of the delegated type *\/$/;"	m	struct:s_delegatedtype
type	cmex.h	/^	PROPERTYTYPE type;$/;"	m	struct:__anon10
type	debug.c	/^	BREAKPOINTTYPE type; \/**< the breakpoint type for this entry *\/$/;"	m	struct:s_breakpoint	file:
type	globals.c	/^	PROPERTYTYPE type;$/;"	m	struct:s_varmap	file:
type	gui.h	/^	GUIENTITYTYPE type;	\/\/ gui entity type (see GE_*)$/;"	m	struct:s_guientity
type	loadshape.h	/^	MACHINETYPE type;	\/**< the type of this machine *\/$/;"	m	struct:s_loadshape
type	object.h	/^		RANDOMTYPE (*type)(char *name);$/;"	m	struct:s_callbacks::__anon35
type	random.c	/^	RANDOMTYPE type;$/;"	m	struct:__anon55	file:
type	server.c	/^    char *type;$/;"	m	struct:s_http	file:
tz	local.h	/^	char tz[32];$/;"	m	struct:s_locale
tz	timestamp.h	/^	char tz[5]; \/**< ptr to tzspec timezone id *\/$/;"	m	struct:s_datetime
tz_dst	timestamp.c	/^char *tz_dst(char *tzspec){$/;"	f
tz_info	timestamp.c	/^int tz_info(char *tzspec, char *tzname, char *std, char *dst, time_t *offset){$/;"	f
tz_name	timestamp.c	/^char *tz_name(char *tzspec){$/;"	f
tz_offset	timestamp.c	/^time_t tz_offset(char *tzspec){$/;"	f
tz_std	timestamp.c	/^char *tz_std(char *tzspec){$/;"	f
tzdst	timestamp.c	/^static char current_tzname[64], tzstd[32], tzdst[32];$/;"	v	file:
tzoffset	timestamp.c	/^static TIMESTAMP tzoffset;$/;"	v	file:
tzset	load.c	165;"	d	file:
tzset	local.c	12;"	d	file:
tzstd	timestamp.c	/^static char current_tzname[64], tzstd[32], tzdst[32];$/;"	v	file:
tzvalid	timestamp.c	/^static int tzvalid=0;$/;"	v	file:
uint32	class.h	/^typedef unsigned int uint32; \/* unsigned 32-bit integers *\/$/;"	t
uniform	object.h	/^		double (*uniform)(double a, double b);$/;"	m	struct:s_callbacks::__anon35
unit	class.h	/^	UNIT *unit; \/**< property unit, if any; \\p NULL if none *\/$/;"	m	struct:s_property_map
unit	gui.h	/^	UNIT *unit;$/;"	m	struct:s_guientity
unit_constant	unit.c	/^int unit_constant(char name, double value)$/;"	f
unit_convert	object.h	/^	int (*unit_convert)(char *from, char *to, double *value);$/;"	m	struct:s_callbacks
unit_convert	unit.c	/^int unit_convert(char *from, char *to, double *pValue){$/;"	f
unit_convert_complex	unit.c	/^int unit_convert_complex(UNIT *pFrom, UNIT *pTo, complex *pValue)$/;"	f
unit_convert_ex	object.h	/^	int (*unit_convert_ex)(UNIT *pFrom, UNIT *pTo, double *pValue);$/;"	m	struct:s_callbacks
unit_convert_ex	unit.c	/^int unit_convert_ex(UNIT *pFrom, UNIT *pTo, double *pValue)$/;"	f
unit_derived	unit.c	/^int unit_derived(char *name,char *derivation)$/;"	f
unit_find	object.h	/^	UNIT *(*unit_find)(char *unit_name);$/;"	m	struct:s_callbacks
unit_find	unit.c	/^UNIT *unit_find(char *unit) \/**< the name of the unit *\/$/;"	f
unit_find_raw	unit.c	/^UNIT *unit_find_raw(char *unit){$/;"	f
unit_find_underived	unit.c	/^UNIT *unit_find_underived(char *unit)$/;"	f
unit_init	unit.c	/^void unit_init(void)$/;"	f
unit_list	unit.c	/^static UNIT *unit_list = NULL;$/;"	v	file:
unit_precision	unit.c	/^int unit_precision(char *term)$/;"	f
unit_primary	unit.c	/^UNIT *unit_primary(char *name, double c, double e, double h, double k, double m, double s, double a, double b, int prec){$/;"	f
unit_scalar	unit.c	/^int unit_scalar(char *name,int scalar)$/;"	f
unit_test	unit.c	/^int unit_test(void)$/;"	f
unitspec	load.c	/^static int unitspec(PARSER, UNIT **unit)$/;"	f	file:
unitsuffix	load.c	/^static int unitsuffix(PARSER, UNIT **unit)$/;"	f	file:
unlock	lock.h	/^static inline void unlock(unsigned int *lock)$/;"	f
ur_state	random.c	/^static unsigned int *ur_state = NULL;$/;"	v	file:
val	load.c	/^	double val; \/\/ if op = 0, check val$/;"	m	struct:s_rpn	file:
valid_to	object.h	/^	TIMESTAMP valid_to;	\/**< object's valid-until time *\/$/;"	m	struct:s_object_list
value	class.h	/^	uint32 value;$/;"	m	struct:s_keyword
value	cmex.h	/^	double value;$/;"	m	struct:__anon8
value	find.c	/^static int value(PARSER, char *result, int size)$/;"	f	file:
value	find.h	/^	FINDVALUE value;$/;"	m	struct:s_findpgm
value	gui.h	/^	char value[1024]; \/\/ value (if provided)$/;"	m	struct:s_guientity
value	load.c	/^static int value(PARSER, char *result, int size)$/;"	f	file:
value	object.h	/^		double (*value)(RANDOMTYPE type, ...);$/;"	m	struct:s_callbacks::__anon35
value	object.h	/^		double (*value)(SCHEDULE *sch, SCHEDULEINDEX index);$/;"	m	struct:s_callbacks::__anon41
value	schedule.h	/^	double value;						\/**< the current scheduled value *\/$/;"	m	struct:s_schedule
var	gui.h	/^	GLOBALVAR *var;$/;"	m	struct:s_guientity
verbose	output.c	/^	FILE *verbose;$/;"	m	struct:s_redirection	file:
voltage_factor	enduse.h	/^	double voltage_factor;		\/* voltage factor (pu nominal) *\/$/;"	m	struct:s_enduse
wait_count	threadpool.c	/^	int thread_count, thread_index, thread_die, wait_count;$/;"	m	struct:threadpool	file:
wait_for_completion	threadpool.c	/^static __inline void wait_for_completion(struct threadpool *tp)$/;"	f	file:
wait_for_completion	threadpool.c	137;"	d	file:
wait_for_completion	threadpool.c	151;"	d	file:
wait_for_exec	threadpool.c	/^static __inline void wait_for_exec(struct threadpool *tp)$/;"	f	file:
wait_for_exec	threadpool.c	134;"	d	file:
wait_for_exec	threadpool.c	149;"	d	file:
warning	output.c	/^	FILE *warning;$/;"	m	struct:s_redirection	file:
watch_sync	debug.c	/^static int watch_sync = 0; \/**< flag indicating that sync times should be reported *\/$/;"	v	file:
watchpoint_count	debug.c	/^static int watchpoint_count=0; \/**< the number of watchpoints defined so far *\/$/;"	v	file:
weekday	timestamp.h	/^	unsigned short weekday; \/**< 0=Sunday *\/$/;"	m	struct:s_datetime
weekdays	loadshape.c	/^static char *weekdays="UMTWRFSH";$/;"	v	file:
weekdays	loadshape.h	/^			unsigned char weekdays;		\/**< bitfield indicating which weekdays the schedule is active (Sun=b0, Mon=b1, etc.) *\/$/;"	m	struct:s_loadshape::__anon24::__anon29
weibull	object.h	/^		double (*weibull)(double a, double b);$/;"	m	struct:s_callbacks::__anon35
weight	schedule.h	/^	unsigned int weight[MAXBLOCKS*MAXVALUES];	\/**< the weight (in minutes) associate with each value *\/$/;"	m	struct:s_schedule
white	find.c	/^static int white(PARSER)$/;"	f	file:
white	load.c	/^static int white(PARSER)$/;"	f	file:
width	gui.h	/^	int width; \/\/ width spec$/;"	m	struct:s_guientity
write_file	load.c	/^static int write_file(FILE *fp, char *data, ...)$/;"	f	file:
year	timestamp.h	/^	unsigned short year; \/**< year (1970 to 2970 is allowed) *\/$/;"	m	struct:s_datetime
yearday	timestamp.h	/^	unsigned short yearday; \/**< 0=Jan 1 *\/$/;"	m	struct:s_datetime
~gldStack	load_xml_handle.h	/^	~gldStack(){if(next != NULL) delete next;}$/;"	f	class:gldStack
